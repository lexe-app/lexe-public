#![allow(
    non_camel_case_types,
    unused,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::double_parens,
    non_snake_case,
    clippy::too_many_arguments
)]
// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.82.6.

use core::panic::UnwindSafe;
use std::{ffi::c_void, sync::Arc};

use flutter_rust_bridge::{rust2dart::IntoIntoDart, *};

use crate::bindings::*;

// Section: imports

// Section: wire functions

fn wire_deploy_env_from_str_impl(
    s: impl Wire2Api<String> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "deploy_env_from_str",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_s = s.wire2api();
            deploy_env_from_str(api_s)
        },
    )
}
fn wire_network_from_str_impl(
    s: impl Wire2Api<String> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "network_from_str",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_s = s.wire2api();
            network_from_str(api_s)
        },
    )
}
fn wire_gen_client_payment_id_impl() -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "gen_client_payment_id",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || Result::<_, ()>::Ok(gen_client_payment_id()),
    )
}
fn wire_form_validate_bitcoin_address_impl(
    address_str: impl Wire2Api<String> + UnwindSafe,
    current_network: impl Wire2Api<Network> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "form_validate_bitcoin_address",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_address_str = address_str.wire2api();
            let api_current_network = current_network.wire2api();
            Result::<_, ()>::Ok(form_validate_bitcoin_address(
                api_address_str,
                api_current_network,
            ))
        },
    )
}
fn wire_form_validate_password_impl(
    password: impl Wire2Api<String> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "form_validate_password",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_password = password.wire2api();
            Result::<_, ()>::Ok(form_validate_password(api_password))
        },
    )
}
fn wire_payment_uri_resolve_best_impl(
    port_: MessagePort,
    network: impl Wire2Api<Network> + UnwindSafe,
    uri_str: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, PaymentMethod, _>(
        WrapInfo {
            debug_name: "payment_uri_resolve_best",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_network = network.wire2api();
            let api_uri_str = uri_str.wire2api();
            move |task_callback| {
                payment_uri_resolve_best(api_network, api_uri_str)
            }
        },
    )
}
fn wire_init_rust_log_stream_impl(
    port_: MessagePort,
    rust_log: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "init_rust_log_stream",
            port: Some(port_),
            mode: FfiCallMode::Stream,
        },
        move || {
            let api_rust_log = rust_log.wire2api();
            move |task_callback| {
                Result::<_, ()>::Ok(init_rust_log_stream(
                    task_callback.stream_sink::<_, String>(),
                    api_rust_log,
                ))
            }
        },
    )
}
fn wire_debug_delete_secret_store_impl(
    config: impl Wire2Api<Config> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "debug_delete_secret_store",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_config = config.wire2api();
            debug_delete_secret_store(api_config)
        },
    )
}
fn wire_debug_delete_latest_provisioned_impl(
    config: impl Wire2Api<Config> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "debug_delete_latest_provisioned",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_config = config.wire2api();
            debug_delete_latest_provisioned(api_config)
        },
    )
}
fn wire_debug_unconditional_panic_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_,_,_,(),_>(WrapInfo{ debug_name: "debug_unconditional_panic", port: Some(port_), mode: FfiCallMode::Normal }, move || {  move |task_callback| Result::<_,()>::Ok(debug_unconditional_panic()) })
}
fn wire_debug_unconditional_error_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "debug_unconditional_error",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| debug_unconditional_error(),
    )
}
fn wire_load__static_method__AppHandle_impl(
    port_: MessagePort,
    config: impl Wire2Api<Config> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, Option<AppHandle>, _>(
        WrapInfo {
            debug_name: "load__static_method__AppHandle",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_config = config.wire2api();
            move |task_callback| AppHandle::load(api_config)
        },
    )
}
fn wire_restore__static_method__AppHandle_impl(
    port_: MessagePort,
    config: impl Wire2Api<Config> + UnwindSafe,
    seed_phrase: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, AppHandle, _>(
        WrapInfo {
            debug_name: "restore__static_method__AppHandle",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_config = config.wire2api();
            let api_seed_phrase = seed_phrase.wire2api();
            move |task_callback| AppHandle::restore(api_config, api_seed_phrase)
        },
    )
}
fn wire_signup__static_method__AppHandle_impl(
    port_: MessagePort,
    config: impl Wire2Api<Config> + UnwindSafe,
    google_auth_code: impl Wire2Api<String> + UnwindSafe,
    password: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, AppHandle, _>(
        WrapInfo {
            debug_name: "signup__static_method__AppHandle",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_config = config.wire2api();
            let api_google_auth_code = google_auth_code.wire2api();
            let api_password = password.wire2api();
            move |task_callback| {
                AppHandle::signup(
                    api_config,
                    api_google_auth_code,
                    api_password,
                )
            }
        },
    )
}
fn wire_node_info__method__AppHandle_impl(
    port_: MessagePort,
    that: impl Wire2Api<AppHandle> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, NodeInfo, _>(
        WrapInfo {
            debug_name: "node_info__method__AppHandle",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_that = that.wire2api();
            move |task_callback| AppHandle::node_info(&api_that)
        },
    )
}
fn wire_fiat_rates__method__AppHandle_impl(
    port_: MessagePort,
    that: impl Wire2Api<AppHandle> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, FiatRates, _>(
        WrapInfo {
            debug_name: "fiat_rates__method__AppHandle",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_that = that.wire2api();
            move |task_callback| AppHandle::fiat_rates(&api_that)
        },
    )
}
fn wire_send_onchain__method__AppHandle_impl(
    port_: MessagePort,
    that: impl Wire2Api<AppHandle> + UnwindSafe,
    req: impl Wire2Api<SendOnchainRequest> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "send_onchain__method__AppHandle",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_that = that.wire2api();
            let api_req = req.wire2api();
            move |task_callback| AppHandle::send_onchain(&api_that, api_req)
        },
    )
}
fn wire_estimate_fee_send_onchain__method__AppHandle_impl(
    port_: MessagePort,
    that: impl Wire2Api<AppHandle> + UnwindSafe,
    req: impl Wire2Api<EstimateFeeSendOnchainRequest> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER
        .wrap::<_, _, _, EstimateFeeSendOnchainResponse, _>(
            WrapInfo {
                debug_name: "estimate_fee_send_onchain__method__AppHandle",
                port: Some(port_),
                mode: FfiCallMode::Normal,
            },
            move || {
                let api_that = that.wire2api();
                let api_req = req.wire2api();
                move |task_callback| {
                    AppHandle::estimate_fee_send_onchain(&api_that, api_req)
                }
            },
        )
}
fn wire_get_address__method__AppHandle_impl(
    port_: MessagePort,
    that: impl Wire2Api<AppHandle> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, String, _>(
        WrapInfo {
            debug_name: "get_address__method__AppHandle",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_that = that.wire2api();
            move |task_callback| AppHandle::get_address(&api_that)
        },
    )
}
fn wire_create_invoice__method__AppHandle_impl(
    port_: MessagePort,
    that: impl Wire2Api<AppHandle> + UnwindSafe,
    req: impl Wire2Api<CreateInvoiceRequest> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, CreateInvoiceResponse, _>(
        WrapInfo {
            debug_name: "create_invoice__method__AppHandle",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_that = that.wire2api();
            let api_req = req.wire2api();
            move |task_callback| AppHandle::create_invoice(&api_that, api_req)
        },
    )
}
fn wire_delete_payment_db__method__AppHandle_impl(
    port_: MessagePort,
    that: impl Wire2Api<AppHandle> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "delete_payment_db__method__AppHandle",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_that = that.wire2api();
            move |task_callback| AppHandle::delete_payment_db(&api_that)
        },
    )
}
fn wire_sync_payments__method__AppHandle_impl(
    port_: MessagePort,
    that: impl Wire2Api<AppHandle> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, bool, _>(
        WrapInfo {
            debug_name: "sync_payments__method__AppHandle",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_that = that.wire2api();
            move |task_callback| AppHandle::sync_payments(&api_that)
        },
    )
}
fn wire_get_payment_by_vec_idx__method__AppHandle_impl(
    that: impl Wire2Api<AppHandle> + UnwindSafe,
    vec_idx: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "get_payment_by_vec_idx__method__AppHandle",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_that = that.wire2api();
            let api_vec_idx = vec_idx.wire2api();
            Result::<_, ()>::Ok(AppHandle::get_payment_by_vec_idx(
                &api_that,
                api_vec_idx,
            ))
        },
    )
}
fn wire_get_short_payment_by_scroll_idx__method__AppHandle_impl(
    that: impl Wire2Api<AppHandle> + UnwindSafe,
    scroll_idx: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "get_short_payment_by_scroll_idx__method__AppHandle",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_that = that.wire2api();
            let api_scroll_idx = scroll_idx.wire2api();
            Result::<_, ()>::Ok(AppHandle::get_short_payment_by_scroll_idx(
                &api_that,
                api_scroll_idx,
            ))
        },
    )
}
fn wire_get_pending_short_payment_by_scroll_idx__method__AppHandle_impl(
    that: impl Wire2Api<AppHandle> + UnwindSafe,
    scroll_idx: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name:
                "get_pending_short_payment_by_scroll_idx__method__AppHandle",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_that = that.wire2api();
            let api_scroll_idx = scroll_idx.wire2api();
            Result::<_, ()>::Ok(
                AppHandle::get_pending_short_payment_by_scroll_idx(
                    &api_that,
                    api_scroll_idx,
                ),
            )
        },
    )
}
fn wire_get_finalized_short_payment_by_scroll_idx__method__AppHandle_impl(
    that: impl Wire2Api<AppHandle> + UnwindSafe,
    scroll_idx: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name:
                "get_finalized_short_payment_by_scroll_idx__method__AppHandle",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_that = that.wire2api();
            let api_scroll_idx = scroll_idx.wire2api();
            Result::<_, ()>::Ok(
                AppHandle::get_finalized_short_payment_by_scroll_idx(
                    &api_that,
                    api_scroll_idx,
                ),
            )
        },
    )
}
fn wire_get_pending_not_junk_short_payment_by_scroll_idx__method__AppHandle_impl(
    that: impl Wire2Api<AppHandle> + UnwindSafe,
    scroll_idx: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(WrapInfo{ debug_name: "get_pending_not_junk_short_payment_by_scroll_idx__method__AppHandle", port: None, mode: FfiCallMode::Sync }, move || { let api_that = that.wire2api();let api_scroll_idx = scroll_idx.wire2api();
                    Result::<_,()>::Ok(AppHandle::get_pending_not_junk_short_payment_by_scroll_idx(&api_that, api_scroll_idx)) })
}
fn wire_get_finalized_not_junk_short_payment_by_scroll_idx__method__AppHandle_impl(
    that: impl Wire2Api<AppHandle> + UnwindSafe,
    scroll_idx: impl Wire2Api<usize> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(WrapInfo{ debug_name: "get_finalized_not_junk_short_payment_by_scroll_idx__method__AppHandle", port: None, mode: FfiCallMode::Sync }, move || { let api_that = that.wire2api();let api_scroll_idx = scroll_idx.wire2api();
                    Result::<_,()>::Ok(AppHandle::get_finalized_not_junk_short_payment_by_scroll_idx(&api_that, api_scroll_idx)) })
}
fn wire_get_num_payments__method__AppHandle_impl(
    that: impl Wire2Api<AppHandle> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "get_num_payments__method__AppHandle",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_that = that.wire2api();
            Result::<_, ()>::Ok(AppHandle::get_num_payments(&api_that))
        },
    )
}
fn wire_get_num_pending_payments__method__AppHandle_impl(
    that: impl Wire2Api<AppHandle> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "get_num_pending_payments__method__AppHandle",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_that = that.wire2api();
            Result::<_, ()>::Ok(AppHandle::get_num_pending_payments(&api_that))
        },
    )
}
fn wire_get_num_finalized_payments__method__AppHandle_impl(
    that: impl Wire2Api<AppHandle> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "get_num_finalized_payments__method__AppHandle",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_that = that.wire2api();
            Result::<_, ()>::Ok(AppHandle::get_num_finalized_payments(
                &api_that,
            ))
        },
    )
}
fn wire_get_num_pending_not_junk_payments__method__AppHandle_impl(
    that: impl Wire2Api<AppHandle> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name: "get_num_pending_not_junk_payments__method__AppHandle",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_that = that.wire2api();
            Result::<_, ()>::Ok(AppHandle::get_num_pending_not_junk_payments(
                &api_that,
            ))
        },
    )
}
fn wire_get_num_finalized_not_junk_payments__method__AppHandle_impl(
    that: impl Wire2Api<AppHandle> + UnwindSafe,
) -> support::WireSyncReturn {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync(
        WrapInfo {
            debug_name:
                "get_num_finalized_not_junk_payments__method__AppHandle",
            port: None,
            mode: FfiCallMode::Sync,
        },
        move || {
            let api_that = that.wire2api();
            Result::<_, ()>::Ok(AppHandle::get_num_finalized_not_junk_payments(
                &api_that,
            ))
        },
    )
}
fn wire_update_payment_note__method__AppHandle_impl(
    port_: MessagePort,
    that: impl Wire2Api<AppHandle> + UnwindSafe,
    req: impl Wire2Api<UpdatePaymentNote> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap::<_, _, _, (), _>(
        WrapInfo {
            debug_name: "update_payment_note__method__AppHandle",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_that = that.wire2api();
            let api_req = req.wire2api();
            move |task_callback| {
                AppHandle::update_payment_note(&api_that, api_req)
            }
        },
    )
}
// Section: wrapper structs

// Section: static checks

// Section: allocate functions

// Section: related functions

// Section: impl Wire2Api

pub trait Wire2Api<T> {
    fn wire2api(self) -> T;
}

impl<T, S> Wire2Api<Option<T>> for *mut S
where
    *mut S: Wire2Api<T>,
{
    fn wire2api(self) -> Option<T> {
        (!self.is_null()).then(|| self.wire2api())
    }
}

impl Wire2Api<bool> for bool {
    fn wire2api(self) -> bool {
        self
    }
}

impl Wire2Api<ConfirmationPriority> for i32 {
    fn wire2api(self) -> ConfirmationPriority {
        match self {
            0 => ConfirmationPriority::High,
            1 => ConfirmationPriority::Normal,
            2 => ConfirmationPriority::Background,
            _ => unreachable!(
                "Invalid variant for ConfirmationPriority: {}",
                self
            ),
        }
    }
}

impl Wire2Api<DeployEnv> for i32 {
    fn wire2api(self) -> DeployEnv {
        match self {
            0 => DeployEnv::Prod,
            1 => DeployEnv::Staging,
            2 => DeployEnv::Dev,
            _ => unreachable!("Invalid variant for DeployEnv: {}", self),
        }
    }
}

impl Wire2Api<i32> for i32 {
    fn wire2api(self) -> i32 {
        self
    }
}
impl Wire2Api<Network> for i32 {
    fn wire2api(self) -> Network {
        match self {
            0 => Network::Mainnet,
            1 => Network::Testnet,
            2 => Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}

impl Wire2Api<u32> for u32 {
    fn wire2api(self) -> u32 {
        self
    }
}
impl Wire2Api<u64> for u64 {
    fn wire2api(self) -> u64 {
        self
    }
}
impl Wire2Api<u8> for u8 {
    fn wire2api(self) -> u8 {
        self
    }
}

impl Wire2Api<usize> for usize {
    fn wire2api(self) -> usize {
        self
    }
}
// Section: impl IntoDart

impl support::IntoDart for AppHandle {
    fn into_dart(self) -> support::DartAbi {
        vec![self.inner.into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for AppHandle {}
impl rust2dart::IntoIntoDart<AppHandle> for AppHandle {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for ClientPaymentId {
    fn into_dart(self) -> support::DartAbi {
        vec![self.id.into_into_dart().into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for ClientPaymentId {}
impl rust2dart::IntoIntoDart<ClientPaymentId> for ClientPaymentId {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for CreateInvoiceResponse {
    fn into_dart(self) -> support::DartAbi {
        vec![self.invoice.into_into_dart().into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for CreateInvoiceResponse {}
impl rust2dart::IntoIntoDart<CreateInvoiceResponse> for CreateInvoiceResponse {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for DeployEnv {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Prod => 0,
            Self::Staging => 1,
            Self::Dev => 2,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DeployEnv {}
impl rust2dart::IntoIntoDart<DeployEnv> for DeployEnv {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for EstimateFeeSendOnchainResponse {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.high.into_dart(),
            self.normal.into_into_dart().into_dart(),
            self.background.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for EstimateFeeSendOnchainResponse {}
impl rust2dart::IntoIntoDart<EstimateFeeSendOnchainResponse>
    for EstimateFeeSendOnchainResponse
{
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for FeeEstimate {
    fn into_dart(self) -> support::DartAbi {
        vec![self.amount_sats.into_into_dart().into_dart()].into_dart()
    }
}
impl support::IntoDartExceptPrimitive for FeeEstimate {}
impl rust2dart::IntoIntoDart<FeeEstimate> for FeeEstimate {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for FiatRate {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.fiat.into_into_dart().into_dart(),
            self.rate.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for FiatRate {}
impl rust2dart::IntoIntoDart<FiatRate> for FiatRate {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for FiatRates {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.timestamp_ms.into_into_dart().into_dart(),
            self.rates.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for FiatRates {}
impl rust2dart::IntoIntoDart<FiatRates> for FiatRates {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for Invoice {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.string.into_into_dart().into_dart(),
            self.description.into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.expires_at.into_into_dart().into_dart(),
            self.amount_sats.into_dart(),
            self.payee_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Invoice {}
impl rust2dart::IntoIntoDart<Invoice> for Invoice {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for Network {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Mainnet => 0,
            Self::Testnet => 1,
            Self::Regtest => 2,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Network {}
impl rust2dart::IntoIntoDart<Network> for Network {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for NodeInfo {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.node_pk.into_into_dart().into_dart(),
            self.version.into_into_dart().into_dart(),
            self.measurement.into_into_dart().into_dart(),
            self.spendable_balance_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for NodeInfo {}
impl rust2dart::IntoIntoDart<NodeInfo> for NodeInfo {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for Onchain {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.address.into_into_dart().into_dart(),
            self.amount_sats.into_dart(),
            self.label.into_dart(),
            self.message.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Onchain {}
impl rust2dart::IntoIntoDart<Onchain> for Onchain {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for Payment {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.index.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.invoice.into_dart(),
            self.replacement.into_dart(),
            self.amount_sat.into_dart(),
            self.fees_sat.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.status_str.into_into_dart().into_dart(),
            self.note.into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.finalized_at.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Payment {}
impl rust2dart::IntoIntoDart<Payment> for Payment {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for PaymentDirection {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Inbound => 0,
            Self::Outbound => 1,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for PaymentDirection {}
impl rust2dart::IntoIntoDart<PaymentDirection> for PaymentDirection {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for PaymentKind {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Onchain => 0,
            Self::Invoice => 1,
            Self::Spontaneous => 2,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for PaymentKind {}
impl rust2dart::IntoIntoDart<PaymentKind> for PaymentKind {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for PaymentMethod {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Onchain(field0) =>
                vec![0.into_dart(), field0.into_into_dart().into_dart()],
            Self::Invoice(field0) =>
                vec![1.into_dart(), field0.into_into_dart().into_dart()],
            Self::Offer => vec![2.into_dart()],
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for PaymentMethod {}
impl rust2dart::IntoIntoDart<PaymentMethod> for PaymentMethod {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for PaymentStatus {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::Pending => 0,
            Self::Completed => 1,
            Self::Failed => 2,
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for PaymentStatus {}
impl rust2dart::IntoIntoDart<PaymentStatus> for PaymentStatus {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for ShortPayment {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.index.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.amount_sat.into_dart(),
            self.status.into_into_dart().into_dart(),
            self.note.into_dart(),
            self.created_at.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for ShortPayment {}
impl rust2dart::IntoIntoDart<ShortPayment> for ShortPayment {
    fn into_into_dart(self) -> Self {
        self
    }
}

impl support::IntoDart for ShortPaymentAndIndex {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.vec_idx.into_into_dart().into_dart(),
            self.payment.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for ShortPaymentAndIndex {}
impl rust2dart::IntoIntoDart<ShortPaymentAndIndex> for ShortPaymentAndIndex {
    fn into_into_dart(self) -> Self {
        self
    }
}

// Section: executor

/* nothing since executor detected */

#[cfg(not(target_family = "wasm"))]
mod io {
    use super::*;
    // Section: wire functions

    #[no_mangle]
    pub extern "C" fn wire_deploy_env_from_str(
        s: *mut wire_uint_8_list,
    ) -> support::WireSyncReturn {
        wire_deploy_env_from_str_impl(s)
    }

    #[no_mangle]
    pub extern "C" fn wire_network_from_str(
        s: *mut wire_uint_8_list,
    ) -> support::WireSyncReturn {
        wire_network_from_str_impl(s)
    }

    #[no_mangle]
    pub extern "C" fn wire_gen_client_payment_id() -> support::WireSyncReturn {
        wire_gen_client_payment_id_impl()
    }

    #[no_mangle]
    pub extern "C" fn wire_form_validate_bitcoin_address(
        address_str: *mut wire_uint_8_list,
        current_network: i32,
    ) -> support::WireSyncReturn {
        wire_form_validate_bitcoin_address_impl(address_str, current_network)
    }

    #[no_mangle]
    pub extern "C" fn wire_form_validate_password(
        password: *mut wire_uint_8_list,
    ) -> support::WireSyncReturn {
        wire_form_validate_password_impl(password)
    }

    #[no_mangle]
    pub extern "C" fn wire_payment_uri_resolve_best(
        port_: i64,
        network: i32,
        uri_str: *mut wire_uint_8_list,
    ) {
        wire_payment_uri_resolve_best_impl(port_, network, uri_str)
    }

    #[no_mangle]
    pub extern "C" fn wire_init_rust_log_stream(
        port_: i64,
        rust_log: *mut wire_uint_8_list,
    ) {
        wire_init_rust_log_stream_impl(port_, rust_log)
    }

    #[no_mangle]
    pub extern "C" fn wire_debug_delete_secret_store(
        config: *mut wire_Config,
    ) -> support::WireSyncReturn {
        wire_debug_delete_secret_store_impl(config)
    }

    #[no_mangle]
    pub extern "C" fn wire_debug_delete_latest_provisioned(
        config: *mut wire_Config,
    ) -> support::WireSyncReturn {
        wire_debug_delete_latest_provisioned_impl(config)
    }

    #[no_mangle]
    pub extern "C" fn wire_debug_unconditional_panic(port_: i64) {
        wire_debug_unconditional_panic_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn wire_debug_unconditional_error(port_: i64) {
        wire_debug_unconditional_error_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn wire_load__static_method__AppHandle(
        port_: i64,
        config: *mut wire_Config,
    ) {
        wire_load__static_method__AppHandle_impl(port_, config)
    }

    #[no_mangle]
    pub extern "C" fn wire_restore__static_method__AppHandle(
        port_: i64,
        config: *mut wire_Config,
        seed_phrase: *mut wire_uint_8_list,
    ) {
        wire_restore__static_method__AppHandle_impl(port_, config, seed_phrase)
    }

    #[no_mangle]
    pub extern "C" fn wire_signup__static_method__AppHandle(
        port_: i64,
        config: *mut wire_Config,
        google_auth_code: *mut wire_uint_8_list,
        password: *mut wire_uint_8_list,
    ) {
        wire_signup__static_method__AppHandle_impl(
            port_,
            config,
            google_auth_code,
            password,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_node_info__method__AppHandle(
        port_: i64,
        that: *mut wire_AppHandle,
    ) {
        wire_node_info__method__AppHandle_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn wire_fiat_rates__method__AppHandle(
        port_: i64,
        that: *mut wire_AppHandle,
    ) {
        wire_fiat_rates__method__AppHandle_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn wire_send_onchain__method__AppHandle(
        port_: i64,
        that: *mut wire_AppHandle,
        req: *mut wire_SendOnchainRequest,
    ) {
        wire_send_onchain__method__AppHandle_impl(port_, that, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_estimate_fee_send_onchain__method__AppHandle(
        port_: i64,
        that: *mut wire_AppHandle,
        req: *mut wire_EstimateFeeSendOnchainRequest,
    ) {
        wire_estimate_fee_send_onchain__method__AppHandle_impl(port_, that, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_address__method__AppHandle(
        port_: i64,
        that: *mut wire_AppHandle,
    ) {
        wire_get_address__method__AppHandle_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn wire_create_invoice__method__AppHandle(
        port_: i64,
        that: *mut wire_AppHandle,
        req: *mut wire_CreateInvoiceRequest,
    ) {
        wire_create_invoice__method__AppHandle_impl(port_, that, req)
    }

    #[no_mangle]
    pub extern "C" fn wire_delete_payment_db__method__AppHandle(
        port_: i64,
        that: *mut wire_AppHandle,
    ) {
        wire_delete_payment_db__method__AppHandle_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn wire_sync_payments__method__AppHandle(
        port_: i64,
        that: *mut wire_AppHandle,
    ) {
        wire_sync_payments__method__AppHandle_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_payment_by_vec_idx__method__AppHandle(
        that: *mut wire_AppHandle,
        vec_idx: usize,
    ) -> support::WireSyncReturn {
        wire_get_payment_by_vec_idx__method__AppHandle_impl(that, vec_idx)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_short_payment_by_scroll_idx__method__AppHandle(
        that: *mut wire_AppHandle,
        scroll_idx: usize,
    ) -> support::WireSyncReturn {
        wire_get_short_payment_by_scroll_idx__method__AppHandle_impl(
            that, scroll_idx,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_get_pending_short_payment_by_scroll_idx__method__AppHandle(
        that: *mut wire_AppHandle,
        scroll_idx: usize,
    ) -> support::WireSyncReturn {
        wire_get_pending_short_payment_by_scroll_idx__method__AppHandle_impl(
            that, scroll_idx,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_get_finalized_short_payment_by_scroll_idx__method__AppHandle(
        that: *mut wire_AppHandle,
        scroll_idx: usize,
    ) -> support::WireSyncReturn {
        wire_get_finalized_short_payment_by_scroll_idx__method__AppHandle_impl(
            that, scroll_idx,
        )
    }

    #[no_mangle]
    pub extern "C" fn wire_get_pending_not_junk_short_payment_by_scroll_idx__method__AppHandle(
        that: *mut wire_AppHandle,
        scroll_idx: usize,
    ) -> support::WireSyncReturn {
        wire_get_pending_not_junk_short_payment_by_scroll_idx__method__AppHandle_impl(that,scroll_idx)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_finalized_not_junk_short_payment_by_scroll_idx__method__AppHandle(
        that: *mut wire_AppHandle,
        scroll_idx: usize,
    ) -> support::WireSyncReturn {
        wire_get_finalized_not_junk_short_payment_by_scroll_idx__method__AppHandle_impl(that,scroll_idx)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_num_payments__method__AppHandle(
        that: *mut wire_AppHandle,
    ) -> support::WireSyncReturn {
        wire_get_num_payments__method__AppHandle_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_num_pending_payments__method__AppHandle(
        that: *mut wire_AppHandle,
    ) -> support::WireSyncReturn {
        wire_get_num_pending_payments__method__AppHandle_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_num_finalized_payments__method__AppHandle(
        that: *mut wire_AppHandle,
    ) -> support::WireSyncReturn {
        wire_get_num_finalized_payments__method__AppHandle_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_num_pending_not_junk_payments__method__AppHandle(
        that: *mut wire_AppHandle,
    ) -> support::WireSyncReturn {
        wire_get_num_pending_not_junk_payments__method__AppHandle_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn wire_get_num_finalized_not_junk_payments__method__AppHandle(
        that: *mut wire_AppHandle,
    ) -> support::WireSyncReturn {
        wire_get_num_finalized_not_junk_payments__method__AppHandle_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn wire_update_payment_note__method__AppHandle(
        port_: i64,
        that: *mut wire_AppHandle,
        req: *mut wire_UpdatePaymentNote,
    ) {
        wire_update_payment_note__method__AppHandle_impl(port_, that, req)
    }

    // Section: allocate functions

    #[no_mangle]
    pub extern "C" fn new_App() -> wire_App {
        wire_App::new_with_null_ptr()
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_app_handle_0() -> *mut wire_AppHandle {
        support::new_leak_box_ptr(wire_AppHandle::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_config_0() -> *mut wire_Config {
        support::new_leak_box_ptr(wire_Config::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_create_invoice_request_0(
    ) -> *mut wire_CreateInvoiceRequest {
        support::new_leak_box_ptr(wire_CreateInvoiceRequest::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_estimate_fee_send_onchain_request_0(
    ) -> *mut wire_EstimateFeeSendOnchainRequest {
        support::new_leak_box_ptr(
            wire_EstimateFeeSendOnchainRequest::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_send_onchain_request_0(
    ) -> *mut wire_SendOnchainRequest {
        support::new_leak_box_ptr(wire_SendOnchainRequest::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_u64_0(value: u64) -> *mut u64 {
        support::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn new_box_autoadd_update_payment_note_0(
    ) -> *mut wire_UpdatePaymentNote {
        support::new_leak_box_ptr(wire_UpdatePaymentNote::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn new_uint_8_list_0(len: i32) -> *mut wire_uint_8_list {
        let ans = wire_uint_8_list {
            ptr: support::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        support::new_leak_box_ptr(ans)
    }

    // Section: related functions

    #[no_mangle]
    pub extern "C" fn drop_opaque_App(ptr: *const c_void) {
        unsafe {
            Arc::<App>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn share_opaque_App(ptr: *const c_void) -> *const c_void {
        unsafe {
            Arc::<App>::increment_strong_count(ptr as _);
            ptr
        }
    }

    // Section: impl Wire2Api

    impl Wire2Api<RustOpaque<App>> for wire_App {
        fn wire2api(self) -> RustOpaque<App> {
            unsafe { support::opaque_from_dart(self.ptr as _) }
        }
    }
    impl Wire2Api<String> for *mut wire_uint_8_list {
        fn wire2api(self) -> String {
            let vec: Vec<u8> = self.wire2api();
            String::from_utf8_lossy(&vec).into_owned()
        }
    }
    impl Wire2Api<AppHandle> for wire_AppHandle {
        fn wire2api(self) -> AppHandle {
            AppHandle {
                inner: self.inner.wire2api(),
            }
        }
    }

    impl Wire2Api<AppHandle> for *mut wire_AppHandle {
        fn wire2api(self) -> AppHandle {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<AppHandle>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<Config> for *mut wire_Config {
        fn wire2api(self) -> Config {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<Config>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<CreateInvoiceRequest> for *mut wire_CreateInvoiceRequest {
        fn wire2api(self) -> CreateInvoiceRequest {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<CreateInvoiceRequest>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<EstimateFeeSendOnchainRequest>
        for *mut wire_EstimateFeeSendOnchainRequest
    {
        fn wire2api(self) -> EstimateFeeSendOnchainRequest {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<EstimateFeeSendOnchainRequest>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<SendOnchainRequest> for *mut wire_SendOnchainRequest {
        fn wire2api(self) -> SendOnchainRequest {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<SendOnchainRequest>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<u64> for *mut u64 {
        fn wire2api(self) -> u64 {
            unsafe { *support::box_from_leak_ptr(self) }
        }
    }
    impl Wire2Api<UpdatePaymentNote> for *mut wire_UpdatePaymentNote {
        fn wire2api(self) -> UpdatePaymentNote {
            let wrap = unsafe { support::box_from_leak_ptr(self) };
            Wire2Api::<UpdatePaymentNote>::wire2api(*wrap).into()
        }
    }
    impl Wire2Api<ClientPaymentId> for wire_ClientPaymentId {
        fn wire2api(self) -> ClientPaymentId {
            ClientPaymentId {
                id: self.id.wire2api(),
            }
        }
    }
    impl Wire2Api<Config> for wire_Config {
        fn wire2api(self) -> Config {
            Config {
                deploy_env: self.deploy_env.wire2api(),
                network: self.network.wire2api(),
                gateway_url: self.gateway_url.wire2api(),
                use_sgx: self.use_sgx.wire2api(),
                base_app_data_dir: self.base_app_data_dir.wire2api(),
                use_mock_secret_store: self.use_mock_secret_store.wire2api(),
            }
        }
    }

    impl Wire2Api<CreateInvoiceRequest> for wire_CreateInvoiceRequest {
        fn wire2api(self) -> CreateInvoiceRequest {
            CreateInvoiceRequest {
                expiry_secs: self.expiry_secs.wire2api(),
                amount_sats: self.amount_sats.wire2api(),
                description: self.description.wire2api(),
            }
        }
    }

    impl Wire2Api<EstimateFeeSendOnchainRequest>
        for wire_EstimateFeeSendOnchainRequest
    {
        fn wire2api(self) -> EstimateFeeSendOnchainRequest {
            EstimateFeeSendOnchainRequest {
                address: self.address.wire2api(),
                amount_sats: self.amount_sats.wire2api(),
            }
        }
    }

    impl Wire2Api<SendOnchainRequest> for wire_SendOnchainRequest {
        fn wire2api(self) -> SendOnchainRequest {
            SendOnchainRequest {
                cid: self.cid.wire2api(),
                address: self.address.wire2api(),
                amount_sats: self.amount_sats.wire2api(),
                priority: self.priority.wire2api(),
                note: self.note.wire2api(),
            }
        }
    }

    impl Wire2Api<[u8; 32]> for *mut wire_uint_8_list {
        fn wire2api(self) -> [u8; 32] {
            let vec: Vec<u8> = self.wire2api();
            support::from_vec_to_array(vec)
        }
    }
    impl Wire2Api<Vec<u8>> for *mut wire_uint_8_list {
        fn wire2api(self) -> Vec<u8> {
            unsafe {
                let wrap = support::box_from_leak_ptr(self);
                support::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl Wire2Api<UpdatePaymentNote> for wire_UpdatePaymentNote {
        fn wire2api(self) -> UpdatePaymentNote {
            UpdatePaymentNote {
                index: self.index.wire2api(),
                note: self.note.wire2api(),
            }
        }
    }

    // Section: wire structs

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_App {
        ptr: *const core::ffi::c_void,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_AppHandle {
        inner: wire_App,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_ClientPaymentId {
        id: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_Config {
        deploy_env: i32,
        network: i32,
        gateway_url: *mut wire_uint_8_list,
        use_sgx: bool,
        base_app_data_dir: *mut wire_uint_8_list,
        use_mock_secret_store: bool,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_CreateInvoiceRequest {
        expiry_secs: u32,
        amount_sats: *mut u64,
        description: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_EstimateFeeSendOnchainRequest {
        address: *mut wire_uint_8_list,
        amount_sats: u64,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_SendOnchainRequest {
        cid: wire_ClientPaymentId,
        address: *mut wire_uint_8_list,
        amount_sats: u64,
        priority: i32,
        note: *mut wire_uint_8_list,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_uint_8_list {
        ptr: *mut u8,
        len: i32,
    }

    #[repr(C)]
    #[derive(Clone)]
    pub struct wire_UpdatePaymentNote {
        index: *mut wire_uint_8_list,
        note: *mut wire_uint_8_list,
    }

    // Section: impl NewWithNullPtr

    pub trait NewWithNullPtr {
        fn new_with_null_ptr() -> Self;
    }

    impl<T> NewWithNullPtr for *mut T {
        fn new_with_null_ptr() -> Self {
            std::ptr::null_mut()
        }
    }

    impl NewWithNullPtr for wire_App {
        fn new_with_null_ptr() -> Self {
            Self {
                ptr: core::ptr::null(),
            }
        }
    }

    impl NewWithNullPtr for wire_AppHandle {
        fn new_with_null_ptr() -> Self {
            Self {
                inner: wire_App::new_with_null_ptr(),
            }
        }
    }

    impl Default for wire_AppHandle {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_ClientPaymentId {
        fn new_with_null_ptr() -> Self {
            Self {
                id: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_ClientPaymentId {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_Config {
        fn new_with_null_ptr() -> Self {
            Self {
                deploy_env: Default::default(),
                network: Default::default(),
                gateway_url: core::ptr::null_mut(),
                use_sgx: Default::default(),
                base_app_data_dir: core::ptr::null_mut(),
                use_mock_secret_store: Default::default(),
            }
        }
    }

    impl Default for wire_Config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_CreateInvoiceRequest {
        fn new_with_null_ptr() -> Self {
            Self {
                expiry_secs: Default::default(),
                amount_sats: core::ptr::null_mut(),
                description: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_CreateInvoiceRequest {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_EstimateFeeSendOnchainRequest {
        fn new_with_null_ptr() -> Self {
            Self {
                address: core::ptr::null_mut(),
                amount_sats: Default::default(),
            }
        }
    }

    impl Default for wire_EstimateFeeSendOnchainRequest {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_SendOnchainRequest {
        fn new_with_null_ptr() -> Self {
            Self {
                cid: Default::default(),
                address: core::ptr::null_mut(),
                amount_sats: Default::default(),
                priority: Default::default(),
                note: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_SendOnchainRequest {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    impl NewWithNullPtr for wire_UpdatePaymentNote {
        fn new_with_null_ptr() -> Self {
            Self {
                index: core::ptr::null_mut(),
                note: core::ptr::null_mut(),
            }
        }
    }

    impl Default for wire_UpdatePaymentNote {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    // Section: sync execution mode utility

    #[no_mangle]
    pub extern "C" fn free_WireSyncReturn(ptr: support::WireSyncReturn) {
        unsafe {
            let _ = support::box_from_leak_ptr(ptr);
        };
    }
}
#[cfg(not(target_family = "wasm"))]
pub use self::io::*;
