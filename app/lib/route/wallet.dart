// The primary wallet page.

import 'dart:async' show StreamController;

import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart' show freezed;
import 'package:intl/intl.dart' show NumberFormat;
import 'package:rxdart_ext/rxdart_ext.dart';

import '../../bindings_generated_api.dart'
    show
        AppHandle,
        Config,
        FiatRate,
        NodeInfo,
        PaymentDirection,
        PaymentKind,
        PaymentStatus,
        ShortPayment;
import '../../components.dart'
    show FilledPlaceholder, StateStreamBuilder, StreamControllerExt;
import '../../currency_format.dart' as currency_format;
import '../../date_format.dart' as date_format;
import '../../logger.dart' show error, info;
import '../../route/send.dart' show SendContext, SendPaymentPage;
import '../../style.dart' show Fonts, LxColors, Space;

// Include code generated by @freezed
part 'wallet.freezed.dart';

class WalletPage extends StatefulWidget {
  const WalletPage({super.key, required this.config, required this.app});

  final Config config;
  final AppHandle app;

  @override
  WalletPageState createState() => WalletPageState();
}

class WalletPageState extends State<WalletPage> {
  final GlobalKey<ScaffoldState> scaffoldKey = GlobalKey();

  /// A stream controller to trigger refreshes of the wallet page contents.
  final StreamController<Null> refresh = StreamController.broadcast();

  /// A stream controller to notify when some payments are updated.
  final StreamController<Null> paymentsUpdated = StreamController.broadcast();

  // BehaviorSubject: a StreamController that captures the latest item added
  // to the controller, and emits that as the first item to any new listener.
  final BehaviorSubject<FiatRate?> fiatRate = BehaviorSubject.seeded(null);
  final BehaviorSubject<NodeInfo?> nodeInfos = BehaviorSubject.seeded(null);

  // StateSubject: like BehaviorSubject but only notifies subscribers if the
  // new item is actually different.
  final StateSubject<BalanceState> balanceStates =
      StateSubject(BalanceState.placeholder);

  @override
  void initState() {
    super.initState();

    final app = this.widget.app;

    // TODO(phlip9): get from user preferences
    const String fiatName = "USD";
    // const String fiatName = "EUR";

    // A stream of `BalanceState`s that gets updated when `nodeInfos` or
    // `fiatRate` are updated. Since it's fed into a `StateSubject`, it also
    // avoids widget rebuilds if new state == old state.
    Rx.combineLatest2(
      this.nodeInfos.map((nodeInfo) => nodeInfo?.localBalanceSats),
      this.fiatRate,
      (balanceSats, fiatRate) => BalanceState(
          balanceSats: balanceSats, fiatName: fiatName, fiatRate: fiatRate),
    ).listen(this.balanceStates.addIfNotClosed);

    // A stream of refreshes, starting with an initial refresh.
    final Stream<Null> refreshRx = this.refresh.stream.startWith(null);

    // on refresh, update the current node info
    refreshRx.asyncMap((_) => app.nodeInfo()).listen(
          this.nodeInfos.addIfNotClosed,
          onError: (err) => error("nodeInfos: error: $err"),
        );

    // on refresh, update fiat rate
    refreshRx
        .asyncMap((_) => app.fiatRates())
        .map((fiatRates) =>
            fiatRates.rates.firstWhere((rate) => rate.fiat == fiatName))
        .listen(
          this.fiatRate.addIfNotClosed,
          onError: (err) => error("fiatRates: error: $err"),
        );

    // on refresh, sync payments from node
    refreshRx.asyncMap((_) => app.syncPayments()).listen(
      (anyChangedPayments) {
        info("syncPayments: anyChangedPayments: $anyChangedPayments");
        // Only re-render payments if they've actually changed.
        if (anyChangedPayments) {
          this.paymentsUpdated.addIfNotClosed(null);
        }
      },
      onError: (err) => error("syncPayments: error: $err"),
    );
  }

  @override
  void dispose() {
    this.refresh.close();
    this.paymentsUpdated.close();
    this.nodeInfos.close();
    this.fiatRate.close();
    this.balanceStates.close();

    super.dispose();
  }

  void openScaffoldDrawer() {
    this.scaffoldKey.currentState?.openDrawer();
  }

  /// Triggers a refresh (fetch balance, fiat rates, payment sync).
  void triggerRefresh() {
    info("refresh triggered");
    this.refresh.addNull();
  }

  /// Called when the "Receive" button is pressed. Pushes the receive payment
  /// page onto the navigation stack.
  void onReceivePressed() {
    info("Receive button pressed");
  }

  /// Called when the "Send" button is pressed. Pushes the send payment page
  /// onto the navigation stack.
  void onSendPressed() {
    final maybeNodeInfo = this.nodeInfos.value;
    if (maybeNodeInfo == null) {
      return;
    }

    final balanceSats = maybeNodeInfo.localBalanceSats;

    // TODO(phlip9): use result of `Navigator.pop()` in page to know whether to
    // resync payments (if a payment was actually made).
    Navigator.of(this.context).push(MaterialPageRoute(
      builder: (context) => SendPaymentPage(
        sendCtx: SendContext.cidFromRng(
          app: this.widget.app,
          configNetwork: this.widget.config.network,
          balanceSats: balanceSats,
        ),
      ),
    ));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      key: this.scaffoldKey,
      extendBodyBehindAppBar: true,
      appBar: AppBar(
        automaticallyImplyLeading: false,

        // ≡ - Open navigation drawer on the left
        leading: IconButton(
          icon: const Icon(Icons.menu_rounded),
          onPressed: this.openScaffoldDrawer,
        ),

        // ⟳ - Trigger refresh of current balance, payments, etc...
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh_rounded),
            onPressed: this.triggerRefresh,
          ),
          const SizedBox(width: Space.s100),
        ],
      ),
      drawer: const WalletDrawer(),
      body: CustomScrollView(
        slivers: [
          // The primary wallet page content
          //
          // * Balance
          // * Wallet Actions (Fund, Receive, Send, ...)
          SliverToBoxAdapter(
              child: Column(children: [
            const SizedBox(height: Space.s1100),
            StateStreamBuilder(
              stream: this.balanceStates,
              builder: (context, balanceState) => BalanceWidget(balanceState),
            ),
            const SizedBox(height: Space.s700),
            WalletActions(
              // + - (doesn't exist yet) fund wallet from exchange integration
              onFundPressed: null,
              // ↓ - Open BTC/LN receive payment page
              onReceivePressed: this.onReceivePressed,
              // ↑ - Open BTC/LN send payment page
              onSendPressed: this.onSendPressed,
            ),
            const SizedBox(height: Space.s900),
          ])),

          // Pending payments + header
          SliverToBoxAdapter(
              child: Padding(
                  padding: const EdgeInsets.only(
                    left: Space.s400,
                    top: Space.s600,
                    bottom: Space.s200,
                  ),
                  child: Text("Pending",
                      style: Fonts.fontUI.copyWith(
                        fontSize: Fonts.size200,
                        color: LxColors.fgTertiary,
                        fontVariations: [Fonts.weightMedium],
                      )))),
          StreamBuilder(
            stream: this.paymentsUpdated.stream,
            initialData: null,
            builder: (context, snapshot) => SliverPaymentsList(
              app: this.widget.app,
              filter: PaymentsListFilter.pending,
            ),
          ),

          // Completed+Failed payments + header
          SliverToBoxAdapter(
              child: Padding(
                  padding: const EdgeInsets.only(
                    left: Space.s400,
                    top: Space.s600,
                    bottom: Space.s200,
                  ),
                  child: Text("Completed",
                      style: Fonts.fontUI.copyWith(
                        fontSize: Fonts.size200,
                        color: LxColors.fgTertiary,
                        fontVariations: [Fonts.weightMedium],
                      )))),
          StreamBuilder(
            stream: this.paymentsUpdated.stream,
            initialData: null,
            builder: (context, snapshot) => SliverPaymentsList(
              app: this.widget.app,
              filter: PaymentsListFilter.finalized,
            ),
          )
        ],
      ),
    );
  }
}

class WalletDrawer extends StatelessWidget {
  const WalletDrawer({
    super.key,
    this.onSettingsPressed,
    this.onBackupPressed,
    this.onSecurityPressed,
    this.onSupportPressed,
    this.onInvitePressed,
  });

  final VoidCallback? onSettingsPressed;
  final VoidCallback? onBackupPressed;
  final VoidCallback? onSecurityPressed;
  final VoidCallback? onSupportPressed;
  final VoidCallback? onInvitePressed;

  @override
  Widget build(BuildContext context) {
    final systemBarHeight = MediaQuery.of(context).padding.top;

    return Drawer(
      child: Padding(
        padding: EdgeInsets.only(top: systemBarHeight),
        child: ListView(
          padding: EdgeInsets.zero,
          children: [
            // X - close
            DrawerListItem(
              icon: Icons.close_rounded,
              onTap: () => Scaffold.of(context).closeDrawer(),
            ),
            const SizedBox(height: Space.s600),

            // * Settings
            // * Backup
            // * Security
            // * Support
            DrawerListItem(
              title: "Settings",
              icon: Icons.settings_outlined,
              onTap: this.onSettingsPressed,
            ),
            DrawerListItem(
              title: "Backup",
              icon: Icons.drive_file_move_outline,
              onTap: this.onBackupPressed,
            ),
            DrawerListItem(
              title: "Security",
              icon: Icons.lock_outline_rounded,
              onTap: this.onSecurityPressed,
            ),
            DrawerListItem(
              title: "Support",
              icon: Icons.help_outline_rounded,
              onTap: this.onSupportPressed,
            ),
            const SizedBox(height: Space.s600),

            // < Invite Friends >
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: Space.s500),
              child: OutlinedButton(
                style: OutlinedButton.styleFrom(
                  backgroundColor: LxColors.background,
                  foregroundColor: LxColors.foreground,
                  side:
                      const BorderSide(color: LxColors.foreground, width: 2.0),
                  padding: const EdgeInsets.symmetric(vertical: Space.s500),
                ),
                onPressed: this.onInvitePressed,
                child: Text("Invite Friends",
                    style: Fonts.fontUI.copyWith(
                      fontSize: Fonts.size400,
                      fontVariations: [Fonts.weightMedium],
                    )),
              ),
            ),
            const SizedBox(height: Space.s600),

            // app version
            Text("Lexe App · v1.2.345",
                textAlign: TextAlign.center,
                style: Fonts.fontUI.copyWith(
                  color: LxColors.grey600,
                  fontSize: Fonts.size200,
                )),
          ],
        ),
      ),
    );
  }
}

class DrawerListItem extends StatelessWidget {
  const DrawerListItem({super.key, this.title, this.icon, this.onTap});

  final String? title;
  final IconData? icon;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      contentPadding: const EdgeInsets.symmetric(horizontal: Space.s500),
      horizontalTitleGap: Space.s200,
      visualDensity: VisualDensity.standard,
      dense: false,
      leading: (this.icon != null)
          ? Icon(this.icon!, color: LxColors.foreground, size: Fonts.size700)
          : null,
      title: (this.title != null)
          ? Text(this.title!,
              style: Fonts.fontUI.copyWith(
                fontSize: Fonts.size400,
                fontVariations: [Fonts.weightMedium],
              ))
          : null,
      onTap: this.onTap,
    );
  }
}

@freezed
class BalanceState with _$BalanceState {
  const factory BalanceState({
    required int? balanceSats,
    required String fiatName,
    required FiatRate? fiatRate,
  }) = _BalanceState;

  const BalanceState._();

  static BalanceState placeholder =
      const BalanceState(balanceSats: null, fiatName: "USD", fiatRate: null);

  double? fiatBalance() => (this.balanceSats != null && this.fiatRate != null)
      ? currency_format.satsToBtc(this.balanceSats!) * this.fiatRate!.rate
      : null;
}

class BalanceWidget extends StatelessWidget {
  const BalanceWidget(this.state, {super.key});

  final BalanceState state;

  @override
  Widget build(BuildContext context) {
    const satsBalanceSize = Fonts.size300;
    final satsBalanceOrPlaceholder = (this.state.balanceSats != null)
        ? Text(
            currency_format.formatSatsAmount(this.state.balanceSats!),
            style: Fonts.fontUI.copyWith(
              fontSize: satsBalanceSize,
              color: LxColors.grey700,
              fontVariations: [Fonts.weightMedium],
            ),
          )
        : const FilledPlaceholder(
            width: Space.s1000,
            height: satsBalanceSize,
            forText: true,
          );

    final fiatBalance = this.state.fiatBalance();
    final fiatBalanceOrPlaceholder = (fiatBalance != null)
        ? PrimaryBalanceText(
            fiatBalance: fiatBalance,
            fiatName: this.state.fiatRate!.fiat,
          )
        : const FilledPlaceholder(
            width: Space.s1100,
            height: Fonts.size800,
            forText: true,
          );

    return Column(
      children: [
        fiatBalanceOrPlaceholder,
        const SizedBox(height: Space.s400),
        satsBalanceOrPlaceholder,
      ],
    );
  }
}

class PrimaryBalanceText extends StatelessWidget {
  const PrimaryBalanceText({
    super.key,
    required this.fiatBalance,
    required this.fiatName,
  });

  final double fiatBalance;
  final String fiatName;

  @override
  Widget build(BuildContext context) {
    final (fiatBalanceWhole, fiatBalanceFract) =
        currency_format.formatFiatParts(this.fiatBalance, this.fiatName);

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          fiatBalanceWhole,
          style: Fonts.fontUI.copyWith(
            fontSize: Fonts.size800,
            fontVariations: [Fonts.weightMedium],
          ),
        ),
        if (fiatBalanceFract.isNotEmpty)
          Text(
            fiatBalanceFract,
            style: Fonts.fontUI.copyWith(
              fontSize: Fonts.size800,
              color: LxColors.fgTertiary,
              fontVariations: [Fonts.weightMedium],
            ),
          ),
      ],
    );
  }
}

class WalletActions extends StatelessWidget {
  const WalletActions({
    super.key,
    this.onFundPressed,
    this.onSendPressed,
    this.onReceivePressed,
  });

  final VoidCallback? onFundPressed;
  final VoidCallback? onSendPressed;
  final VoidCallback? onReceivePressed;

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        WalletActionButton(
          onPressed: this.onFundPressed,
          icon: Icons.add_rounded,
          label: "Fund",
        ),
        const SizedBox(width: Space.s400),
        WalletActionButton(
          onPressed: this.onReceivePressed,
          icon: Icons.arrow_downward_rounded,
          label: "Receive",
        ),
        const SizedBox(width: Space.s400),
        WalletActionButton(
          onPressed: this.onSendPressed,
          icon: Icons.arrow_upward_rounded,
          label: "Send",
        ),
      ],
    );
  }
}

class WalletActionButton extends StatelessWidget {
  const WalletActionButton({
    super.key,
    required this.onPressed,
    required this.icon,
    required this.label,
  });

  final VoidCallback? onPressed;
  final IconData icon;
  final String label;

  @override
  Widget build(BuildContext context) {
    final bool isDisabled = (this.onPressed == null);

    return Column(
      children: [
        FilledButton(
          onPressed: this.onPressed,
          style: FilledButton.styleFrom(
            backgroundColor: LxColors.grey975,
            disabledBackgroundColor: LxColors.grey850,
            foregroundColor: LxColors.foreground,
            disabledForegroundColor: LxColors.grey725,
          ),
          child: Padding(
            padding: const EdgeInsets.all(Space.s400),
            child: Icon(this.icon, size: Fonts.size700),
          ),
        ),
        const SizedBox(height: Space.s400),
        Text(
          label,
          style: Fonts.fontUI.copyWith(
            fontSize: Fonts.size300,
            color: (!isDisabled) ? LxColors.foreground : LxColors.grey725,
            fontVariations: [Fonts.weightSemiBold],
          ),
        ),
      ],
    );
  }
}

enum PaymentsListFilter {
  all,
  pending,
  finalized,
}

class SliverPaymentsList extends StatelessWidget {
  const SliverPaymentsList({
    super.key,
    required this.app,
    required this.filter,
  });

  final AppHandle app;
  final PaymentsListFilter filter;

  @override
  Widget build(BuildContext context) {
    final int childCount;
    if (this.filter == PaymentsListFilter.all) {
      childCount = this.app.getNumPayments();
    } else if (this.filter == PaymentsListFilter.pending) {
      childCount = this.app.getNumPendingPayments();
    } else {
      childCount = this.app.getNumFinalizedPayments();
    }
    info(
        "build SliverPaymentsList: filter: ${this.filter}, childCount: $childCount");

    return SliverFixedExtentList(
      itemExtent: Space.s825,
      delegate: SliverChildBuilderDelegate(
        (context, scrollIdx) {
          final ShortPayment? payment;

          if (this.filter == PaymentsListFilter.all) {
            payment = this.app.getPaymentByScrollIdx(scrollIdx: scrollIdx);
          } else if (this.filter == PaymentsListFilter.pending) {
            payment =
                this.app.getPendingPaymentByScrollIdx(scrollIdx: scrollIdx);
          } else {
            payment =
                this.app.getFinalizedPaymentByScrollIdx(scrollIdx: scrollIdx);
          }

          if (payment != null) {
            return PaymentsListEntry(payment: payment);
          } else {
            return null;
          }
        },
        childCount: childCount,
        // findChildIndexCallback: (Key childKey) => this.app.getPaymentScrollIdxByPaymentId(childKey),
      ),
    );
  }
}

String formatFiatValue({
  required FiatRate? rate,
  required int? amountSats,
  required PaymentDirection direction,
}) {
  if (rate == null || amountSats == null) {
    return "";
  }

  final fiatValue = currency_format.satsToBtc(amountSats) * rate.rate;
  final sign = currency_format.directionToSign(direction);

  final NumberFormat currencyFormatter =
      NumberFormat.simpleCurrency(name: rate.fiat);
  return "$sign${currencyFormatter.format(fiatValue)}";
}

class PaymentsListEntry extends StatelessWidget {
  PaymentsListEntry({required this.payment}) : super(key: Key(payment.index));

  final ShortPayment payment;

  @override
  Widget build(BuildContext context) {
    final status = this.payment.status;
    final direction = this.payment.direction;
    final kind = this.payment.kind;
    final amountSats = this.payment.amountSat;
    final note = this.payment.note;

    final leadingIcon = PaymentListIcon(kind: kind);

    // TODO(phlip9): figure out a heuristic to get the counterparty name.
    final String primaryStr;
    if (status == PaymentStatus.Pending) {
      if (direction == PaymentDirection.Inbound) {
        primaryStr = "Receiving payment";
      } else {
        primaryStr = "Sending payment";
      }
    } else {
      if (direction == PaymentDirection.Inbound) {
        primaryStr = "You received";
      } else {
        primaryStr = "You sent";
      }
    }

    // ex: "Receiving payment" (pending, inbound)
    // ex: "Sending payment" (pending, outbound)
    // ex: "You received" (finalized, inbound)
    // ex: "You sent" (finalized, outbound)
    final primaryText = Text(
      primaryStr,
      maxLines: 1,
      style: Fonts.fontUI.copyWith(
        fontSize: Fonts.size300,
        color: LxColors.fgSecondary,
        fontVariations: [Fonts.weightMedium],
      ),
    );

    // TODO(phlip9): display as BTC rather than sats depending on user
    //               preferences.
    // the weird unicode thing that isn't rendering is the BTC B currency symbol
    // "+₿0.00001230",

    final Color primaryValueColor;
    if (direction == PaymentDirection.Inbound &&
        status != PaymentStatus.Failed) {
      primaryValueColor = LxColors.moneyGoUp;
    } else {
      primaryValueColor = LxColors.fgSecondary;
    }

    final String amountSatsStr = (amountSats != null)
        ? currency_format.formatSatsAmount(amountSats,
            direction: direction, satsSuffix: true)
        : "";

    // ex: "" (certain niche cases w/ failed or pending LN invoice payments)
    // ex: "+45,000 sats"
    // ex: "-128 sats"
    final primaryValueText = Text(
      amountSatsStr,
      maxLines: 1,
      textAlign: TextAlign.end,
      style: Fonts.fontUI.copyWith(
        fontSize: Fonts.size200,
        color: primaryValueColor,
      ),
    );

    // ex: "Failed" (payment failed, no note)
    // ex: "Brunch with friends" (note only)
    // ex: "Failed · Funds from Boincase" (failed + note)
    final secondaryText = RichText(
      text: TextSpan(
        text: null,
        children: <TextSpan>[
          // prefix with "Failed" to indicate problem w/ payment.
          if (status == PaymentStatus.Failed)
            const TextSpan(
              text: "Failed",
              style: TextStyle(
                color: LxColors.errorText,
                // fontVariations: [Fonts.weightMedium],
              ),
            ),
          // separator should only show if both sides are present
          if (status == PaymentStatus.Failed && note != null)
            const TextSpan(text: " · "),
          if (note != null) TextSpan(text: note)
        ],
        style: Fonts.fontUI.copyWith(
          fontSize: Fonts.size200,
          color: LxColors.fgTertiary,
        ),
      ),
      maxLines: 1,
      overflow: TextOverflow.ellipsis,
    );

    final createdAt = DateTime.fromMillisecondsSinceEpoch(payment.createdAt);
    final createdAtStr = date_format.formatDateCompact(then: createdAt);

    // ex: "10min"
    // ex: "Jun 16"
    // ex: "14h"
    final secondaryDateText = Text(
      createdAtStr ?? "",
      maxLines: 1,
      textAlign: TextAlign.end,
      style: Fonts.fontUI.copyWith(
        fontSize: Fonts.size200,
        color: LxColors.fgTertiary,
      ),
    );

    return ListTile(
      // list tile styling

      contentPadding: const EdgeInsets.symmetric(
        horizontal: Space.s400,
        vertical: Space.s0,
      ),
      horizontalTitleGap: Space.s200,
      visualDensity: VisualDensity.standard,
      dense: false,

      // actual content

      leading: leadingIcon,

      // NOTE: we use a Row() in `title` and `subtitle` instead of `trailing` so
      // that the text baselines align properly.

      title: Row(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.baseline,
        textBaseline: TextBaseline.alphabetic,
        children: [
          Expanded(
            child: primaryText,
          ),
          Padding(
            padding: const EdgeInsets.only(left: Space.s200),
            child: primaryValueText,
          )
        ],
      ),

      subtitle: Row(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.baseline,
        textBaseline: TextBaseline.alphabetic,
        children: [
          Expanded(
            child: secondaryText,
          ),
          Padding(
            padding: const EdgeInsets.only(left: Space.s200),
            child: secondaryDateText,
          )
        ],
      ),
    );
  }
}

class PaymentListIcon extends StatelessWidget {
  const PaymentListIcon({
    super.key,
    required this.kind,
  });

  final PaymentKind kind;

  @override
  Widget build(BuildContext context) {
    final icon = (this.kind == PaymentKind.Onchain)
        ? Icons.currency_bitcoin_rounded
        : Icons.bolt_rounded;

    return DecoratedBox(
      decoration: const BoxDecoration(
        color: LxColors.grey850,
        borderRadius: BorderRadius.all(Radius.circular(20.0)),
      ),
      child: SizedBox.square(
        // pixel perfect alignment
        dimension: 39.0,
        child: Icon(
          icon,
          size: Space.s500,
          color: LxColors.fgSecondary,
        ),
      ),
    );
  }
}
