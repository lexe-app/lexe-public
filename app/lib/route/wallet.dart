// The primary wallet page.

import 'dart:async' show StreamController;

import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart' show freezed;
import 'package:intl/intl.dart' show NumberFormat;
import 'package:rxdart_ext/rxdart_ext.dart';

import '../../bindings_generated_api.dart'
    show
        AppHandle,
        BasicPayment,
        FiatRate,
        FiatRates,
        NodeInfo,
        PaymentDirection;
import '../../date_format.dart' as date_format;
import '../../logger.dart' show error, info;
import '../../style.dart' show Fonts, LxColors, LxRadius, Space;

// Include code generated by @freezed
part 'wallet.freezed.dart';

class WalletPage extends StatefulWidget {
  const WalletPage({super.key, required this.app});

  final AppHandle app;

  @override
  WalletPageState createState() => WalletPageState();
}

class WalletPageState extends State<WalletPage> {
  /// A stream controller to trigger refreshes of the wallet page contents.
  final StreamController<Null> refresh = StreamController.broadcast();

  // BehaviorSubject: a StreamController that captures the latest item added
  // to the controller, and emits that as the first item to any new listener.
  final BehaviorSubject<FiatRates?> fiatRates = BehaviorSubject.seeded(null);
  final BehaviorSubject<NodeInfo?> nodeInfos = BehaviorSubject.seeded(null);

  // StateSubject: like BehaviorSubject but only notifies subscribers if the
  // new item is actually different.
  final StateSubject<BalanceState> balanceStates =
      StateSubject(BalanceState.placeholder);

  @override
  void initState() {
    super.initState();

    final app = this.widget.app;

    // TODO(phlip9): get from user preferences
    const String fiatName = "USD";

    // A stream of `BalanceState`s that gets updated when `nodeInfos` or
    // `fiatRates` are updated. Since it's fed into a `StateSubject`, it also
    // avoids widget rebuilds if new state == old state.
    Rx.combineLatest2(
      this.nodeInfos.map((nodeInfo) => nodeInfo?.localBalanceMsat),
      this.fiatRates.map((fiatRates) =>
          fiatRates?.rates.firstWhere((rate) => rate.fiat == fiatName)),
      (msatBalance, fiatRate) => BalanceState(
          msatsBalance: msatBalance, fiatName: fiatName, fiatRate: fiatRate),
    ).listen(this.balanceStates.addIfNotClosed);

    // A stream of refreshes, starting with an initial refresh.
    final Stream<Null> refreshRx = this.refresh.stream.startWith(null);

    // on refresh, update the current node info
    refreshRx.asyncMap((_) => app.nodeInfo()).listen(
          this.nodeInfos.addIfNotClosed,
          onError: (err) => error("nodeInfos: error: $err"),
        );

    // on refresh, update fiat rate
    refreshRx.asyncMap((_) => app.fiatRates()).listen(
          this.fiatRates.addIfNotClosed,
          onError: (err) => error("fiatRates: error: $err"),
        );

    // on refresh, sync payments from node
    refreshRx.asyncMap((_) => app.syncPayments()).listen(
      (anyChangedPayments) {
        info("syncPayments: anyChangedPayments: $anyChangedPayments");
        // TODO(phlip9): notify payments list UI to update
      },
      onError: (err) => error("syncPayments: error: $err"),
    );
  }

  @override
  void dispose() {
    this.refresh.close();
    this.nodeInfos.close();
    this.fiatRates.close();
    this.balanceStates.close();

    super.dispose();
  }

  void triggerRefresh() {
    info("refresh triggered");
    this.refresh.addNull();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: AppBar(
        automaticallyImplyLeading: false,

        // transparent bg header
        // TODO(phlip9): the action icons collide w/ the scrolled content. maybe
        // scroll this AppBar along with the content?
        backgroundColor: LxColors.clearB0,
        scrolledUnderElevation: 0.0,
        surfaceTintColor: LxColors.clearB0,

        // // header shadow effect
        // // not sure I like how this looks...
        // scrolledUnderElevation: 5.0,
        // shadowColor: LxColors.background,
        // surfaceTintColor: LxColors.clearB0,
        leading: Builder(
          builder: (context) => IconButton(
            iconSize: Fonts.size700,
            icon: const Icon(Icons.menu_rounded),
            onPressed: () => Scaffold.of(context).openDrawer(),
          ),
        ),
        actions: [
          IconButton(
            iconSize: Fonts.size700,
            icon: const Icon(Icons.refresh_rounded),
            onPressed: () => this.triggerRefresh(),
          ),
          const SizedBox(width: Space.s100),
        ],
      ),
      drawer: const WalletDrawer(),
      body: CustomScrollView(
        slivers: [
          // The primary wallet page content
          //
          // * Balance
          // * Wallet Actions (Fund, Receive, Send, ...)
          SliverList(
              delegate: SliverChildListDelegate([
            const SizedBox(height: Space.s1100),
            // TODO(phlip9): for some reason, when we scroll down and then back
            // up, this widget resets to loading placeholders...
            StateStreamBuilder(
              stream: this.balanceStates,
              builder: (context, balanceState) => BalanceWidget(balanceState),
            ),
            const SizedBox(height: Space.s700),
            const WalletActions(),
            const SizedBox(height: Space.s900),
            // TODO(phlip9): is there a  way to easily shove the filters into
            // the `SliverPaymentsList`?
            // const PaymentsListFilters(),
            // const SizedBox(height: Space.s400),
          ])),

          // The payments list
          //
          SliverPaymentsList(app: this.widget.app),
        ],
      ),
      // TODO(phlip9): this default pull-to-refresh is really not great...
      // body: RefreshIndicator(
      //   backgroundColor: LxColors.background,
      //   color: LxColors.foreground,
      //   onRefresh: () async {
      //     refreshTx.add(null);
      //     await Future.delayed(const Duration(seconds: 1));
      //   },
      //   child: ListView(
      //     children: const [
      //       SizedBox(height: Space.s1000),
      //       BalanceWidget(),
      //       SizedBox(height: Space.s700),
      //       WalletActions(),
      //     ],
      //   ),
      // ),
    );
  }
}

typedef StateStreamWidgetBuilder<T> = Widget Function(
  BuildContext context,
  T data,
);

/// A small helper `Widget` that builds a new widget everytime a `StateStream`
/// gets an update.
///
/// This is slightly nicer than the standard `StreamBuilder` because
/// `StateStream`s always have an initial value and never error.
class StateStreamBuilder<T> extends StreamBuilder<T> {
  StateStreamBuilder({
    super.key,
    required StateStream<T> stream,
    required StateStreamWidgetBuilder builder,
  }) : super(
          stream: stream,
          initialData: stream.value,
          builder: (BuildContext context, AsyncSnapshot<T> snapshot) =>
              builder(context, snapshot.data),
        );
}

extension StreamControllerExt<T> on StreamController<T> {
  /// Calls `add(event)` as long as the `StreamController` is not already
  /// closed.
  void addIfNotClosed(T event) {
    if (!this.isClosed) {
      this.add(event);
    }
  }
}

class WalletDrawer extends StatelessWidget {
  const WalletDrawer({super.key});

  @override
  Widget build(BuildContext context) {
    final systemBarHeight = MediaQuery.of(context).padding.top;

    return Drawer(
      child: Padding(
        padding: EdgeInsets.only(top: systemBarHeight),
        child: ListView(
          padding: EdgeInsets.zero,
          children: [
            // X - close
            DrawerListItem(
              icon: Icons.close_rounded,
              onTap: () => Scaffold.of(context).closeDrawer(),
            ),
            const SizedBox(height: Space.s600),

            // * Settings
            // * Backup
            // * Security
            // * Support
            DrawerListItem(
              title: "Settings",
              icon: Icons.settings_outlined,
              onTap: () => info("settings pressed"),
            ),
            DrawerListItem(
              title: "Backup",
              icon: Icons.drive_file_move_outline,
              onTap: () => info("backup pressed"),
            ),
            DrawerListItem(
              title: "Security",
              icon: Icons.lock_outline_rounded,
              onTap: () => info("security pressed"),
            ),
            DrawerListItem(
              title: "Support",
              icon: Icons.help_outline_rounded,
              onTap: () => info("support pressed"),
            ),
            const SizedBox(height: Space.s600),

            // < Invite Friends >
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: Space.s500),
              child: OutlinedButton(
                style: OutlinedButton.styleFrom(
                  backgroundColor: LxColors.background,
                  foregroundColor: LxColors.foreground,
                  side:
                      const BorderSide(color: LxColors.foreground, width: 2.0),
                  padding: const EdgeInsets.symmetric(vertical: Space.s500),
                ),
                onPressed: () => info("invite pressed"),
                child: Text("Invite Friends",
                    style: Fonts.fontUI.copyWith(
                      fontSize: Fonts.size400,
                      fontVariations: [Fonts.weightMedium],
                    )),
              ),
            ),
            const SizedBox(height: Space.s600),

            // app version
            Text("Lexe App Â· v1.2.345",
                textAlign: TextAlign.center,
                style: Fonts.fontUI.copyWith(
                  color: LxColors.grey600,
                  fontSize: Fonts.size200,
                )),
          ],
        ),
      ),
    );
  }
}

class DrawerListItem extends StatelessWidget {
  const DrawerListItem({super.key, this.title, this.icon, this.onTap});

  final String? title;
  // final String? subtitle;
  final IconData? icon;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      contentPadding: const EdgeInsets.symmetric(horizontal: Space.s500),
      horizontalTitleGap: Space.s200,
      visualDensity: VisualDensity.standard,
      dense: false,
      leading: (this.icon != null)
          ? Icon(this.icon!, color: LxColors.foreground, size: Fonts.size700)
          : null,
      title: (this.title != null)
          ? Text(this.title!,
              style: Fonts.fontUI.copyWith(
                fontSize: Fonts.size400,
                fontVariations: [Fonts.weightMedium],
              ))
          : null,
      // subtitle: (this.subtitle != null)
      //     ? Text(this.subtitle!,
      //         style: Fonts.fontUI
      //             .copyWith(fontSize: Fonts.size300, color: LxColors.grey600))
      //     : null,
      onTap: this.onTap,
    );
  }
}

final NumberFormat integerFormatter =
    NumberFormat.decimalPatternDigits(decimalDigits: 0);

String formatSats(double sats) => "${integerFormatter.format(sats)} sats";

double msatsToSats(int msats) => msats * 1e-3;
double msatsToBtc(int msats) => msats * 1e-11;

@freezed
class BalanceState with _$BalanceState {
  const factory BalanceState({
    required int? msatsBalance,
    required String fiatName,
    required FiatRate? fiatRate,
  }) = _BalanceState;

  const BalanceState._();

  static BalanceState placeholder =
      const BalanceState(msatsBalance: null, fiatName: "USD", fiatRate: null);

  double? fiatBalance() => (this.msatsBalance != null && this.fiatRate != null)
      ? msatsToBtc(this.msatsBalance!) * this.fiatRate!.rate
      : null;
}

class BalanceWidget extends StatelessWidget {
  const BalanceWidget(this.state, {super.key});

  final BalanceState state;

  @override
  Widget build(BuildContext context) {
    const satsBalanceSize = Fonts.size300;
    final satsBalanceOrPlaceholder = (this.state.msatsBalance != null)
        ? Text(
            formatSats(msatsToSats(this.state.msatsBalance!)),
            style: Fonts.fontUI.copyWith(
              fontSize: satsBalanceSize,
              color: LxColors.grey700,
              fontVariations: [Fonts.weightMedium],
            ),
          )
        : const FilledPlaceholder(
            width: Space.s1000,
            height: satsBalanceSize,
            forText: true,
          );

    final fiatBalance = this.state.fiatBalance();
    final fiatBalanceOrPlaceholder = (fiatBalance != null)
        ? PrimaryBalanceText(
            fiatBalance: fiatBalance,
            fiatName: this.state.fiatRate!.fiat,
          )
        : const FilledPlaceholder(
            width: Space.s1100,
            height: Fonts.size800,
            forText: true,
          );

    return Column(
      children: [
        fiatBalanceOrPlaceholder,
        const SizedBox(height: Space.s400),
        satsBalanceOrPlaceholder,
      ],
    );
  }
}

/// A simple colored box that we can show while some real content is loading.
///
/// The `width` and `height` are optional. If left `null`, that dimension will
/// be determined by the parent `Widget`'s constraints.
///
/// If the placeholder is replacing some text, `forText` should be set to `true`.
/// This is because a `Text` widget's actual rendered height also depends on the
/// current `MediaQuery.textScaleFactor`.
class FilledPlaceholder extends StatelessWidget {
  const FilledPlaceholder({
    super.key,
    this.color = LxColors.grey850,
    this.width = double.infinity,
    this.height = double.infinity,
    this.borderRadius = LxRadius.r200,
    this.forText = false,
    this.child,
  });

  final Color color;
  final double width;
  final double height;
  final double borderRadius;
  final bool forText;
  final Widget? child;

  @override
  Widget build(BuildContext context) {
    final double heightFactor;
    if (!this.forText) {
      heightFactor = 1.0;
    } else {
      heightFactor = MediaQuery.of(context).textScaleFactor;
    }

    return SizedBox(
      width: this.width,
      height: this.height * heightFactor,
      child: DecoratedBox(
        decoration: BoxDecoration(
          color: this.color,
          borderRadius: BorderRadius.circular(this.borderRadius),
        ),
        child: this.child,
      ),
    );
  }
}

class PrimaryBalanceText extends StatelessWidget {
  const PrimaryBalanceText({
    super.key,
    required this.fiatBalance,
    required this.fiatName,
  });

  final double fiatBalance;
  final String fiatName;

  @override
  Widget build(BuildContext context) {
    final NumberFormat currencyFormatter = NumberFormat.simpleCurrency(
      name: this.fiatName,
    );
    final fiatBalanceStr = currencyFormatter.format(this.fiatBalance);

    final decimalSeparator = currencyFormatter.symbols.DECIMAL_SEP;
    final maybeDecimalIdx = fiatBalanceStr.lastIndexOf(decimalSeparator);

    // ex: fiatBalance = 123.45679
    //     fiatBalanceSignificant = "$123"
    //     fiatBalanceFractional = ".46"
    final String fiatBalanceSignificant;
    final String? fiatBalanceFractional;

    if (maybeDecimalIdx >= 0) {
      fiatBalanceSignificant = fiatBalanceStr.substring(0, maybeDecimalIdx);
      fiatBalanceFractional = fiatBalanceStr.substring(maybeDecimalIdx);
    } else {
      fiatBalanceSignificant = fiatBalanceStr;
      fiatBalanceFractional = null;
    }

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          fiatBalanceSignificant,
          style: Fonts.fontUI.copyWith(
            fontSize: Fonts.size800,
            fontVariations: [Fonts.weightMedium],
          ),
        ),
        if (fiatBalanceFractional != null)
          Text(
            fiatBalanceFractional,
            style: Fonts.fontUI.copyWith(
              fontSize: Fonts.size800,
              color: LxColors.grey650,
              fontVariations: [Fonts.weightMedium],
            ),
          ),
      ],
    );
  }
}

class WalletActions extends StatelessWidget {
  const WalletActions({super.key});

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        const WalletActionButton(
          onPressed: null,
          icon: Icons.add_rounded,
          label: "Fund",
        ),
        const SizedBox(width: Space.s400),
        WalletActionButton(
          onPressed: () => info("recv pressed"),
          icon: Icons.arrow_downward_rounded,
          label: "Receive",
        ),
        const SizedBox(width: Space.s400),
        WalletActionButton(
          onPressed: () => info("send pressed"),
          icon: Icons.arrow_upward_rounded,
          label: "Send",
        ),
      ],
    );
  }
}

class WalletActionButton extends StatelessWidget {
  const WalletActionButton({
    super.key,
    required this.onPressed,
    required this.icon,
    required this.label,
  });

  final VoidCallback? onPressed;
  final IconData icon;
  final String label;

  @override
  Widget build(BuildContext context) {
    final bool isDisabled = (this.onPressed == null);

    return Column(
      children: [
        FilledButton(
          onPressed: this.onPressed,
          style: FilledButton.styleFrom(
            backgroundColor: LxColors.grey975,
            disabledBackgroundColor: LxColors.grey850,
            foregroundColor: LxColors.foreground,
            disabledForegroundColor: LxColors.grey725,
          ),
          child: Padding(
            padding: const EdgeInsets.all(Space.s400),
            child: Icon(this.icon, size: Fonts.size700),
          ),
        ),
        const SizedBox(height: Space.s400),
        Text(
          label,
          style: Fonts.fontUI.copyWith(
            fontSize: Fonts.size300,
            color: (!isDisabled) ? LxColors.foreground : LxColors.grey725,
            fontVariations: [Fonts.weightSemiBold],
          ),
        ),
      ],
    );
  }
}

class PaymentsListFilters extends StatelessWidget {
  const PaymentsListFilters({super.key});

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.start,
      children: const [
        SizedBox(width: Space.s600),
        FilledPlaceholder(
          height: Space.s600,
          width: Space.s800,
        ),
        SizedBox(width: Space.s400),
        FilledPlaceholder(
          height: Space.s600,
          width: Space.s800,
        ),
        SizedBox(width: Space.s400),
        FilledPlaceholder(
          height: Space.s600,
          width: Space.s800,
        ),
      ],
    );
  }
}

class SliverPaymentsList extends StatelessWidget {
  const SliverPaymentsList({super.key, required this.app});

  final AppHandle app;

  @override
  Widget build(BuildContext context) {
    final numPayments = this.app.getNumPayments();

    // TODO(phlip9): also investigate more efficient `SliverFixedExtentList`,
    // since each payment list entry should be the same height.
    return SliverList(
        delegate: SliverChildBuilderDelegate(
      (context, scrollIdx) {
        final payment = this.app.getPaymentByScrollIdx(scrollIdx: scrollIdx);

        if (payment != null) {
          // final amount = payment.
          return PaymentsListEntry(payment);
        } else {
          return null;
        }
      },
      childCount: numPayments,
      // TODO(phlip9): I think we'll need to implement this so that
      // findChildIndexCallback: (Key childKey) => this.app.getPaymentScrollIdxByPaymentId(childKey),
    ));
  }
}

class PaymentsListEntry extends StatelessWidget {
  PaymentsListEntry(this.payment) : super(key: Key(payment.index));

  final BasicPayment payment;

  @override
  Widget build(BuildContext context) {
    final createdAt = DateTime.fromMillisecondsSinceEpoch(payment.createdAt);
    // If `createdAt` is somehow in the future, just hide it.
    final createdAtStr = date_format.formatDateCompact(then: createdAt) ?? "";

    return ListTile(
      // list tile styling
      contentPadding: const EdgeInsets.symmetric(
        horizontal: Space.s400,
        vertical: Space.s200,
      ),
      horizontalTitleGap: Space.s200,
      visualDensity: VisualDensity.standard,
      dense: false,

      // actual content
      leading: PaymentListIcon(direction: this.payment.direction),
      title: Text(
        // TODO(phlip9): I don't think the txid / payment hash are particularly
        // useful from a UX standpoint. Ideally the primary display line is the
        // human-readable txn counterparty.
        this.payment.id.substring(3),
        maxLines: 1,
        // overflow: TextOverflow.ellipsis,
        style: Fonts.fontUI.copyWith(
          fontSize: Fonts.size300,
          color: LxColors.grey350,
          fontVariations: [Fonts.weightMedium],
        ),
      ),

      subtitle: Text(
        createdAtStr,
        maxLines: 1,
        style: Fonts.fontUI.copyWith(
          fontSize: Fonts.size200,
          color: LxColors.grey650,
        ),
      ),

      // TODO(phlip9): I think we need to move the tx amounts to the
      // title/subtitle widgets so they can align on the right text baseline...
      trailing: SizedBox(
        width: Space.s1000,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.start,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Padding(
              padding: const EdgeInsets.only(top: 10.0),
              child: Text(
                // the weird unicode thing that isn't rendering is the BTC B
                // currency symbol
                "+â¿0.00001230",
                // "23,856 sats",
                maxLines: 1,
                style: Fonts.fontUI.copyWith(
                  fontSize: Fonts.size200,
                  color: LxColors.grey350,
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.only(top: Space.s200),
              child: Text(
                "\$5.12",
                maxLines: 1,
                style: Fonts.fontUI.copyWith(
                  fontSize: Fonts.size200,
                  color: LxColors.grey650,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class PaymentListIcon extends StatelessWidget {
  const PaymentListIcon({super.key, required this.direction});

  final PaymentDirection direction;

  @override
  Widget build(BuildContext context) {
    const iconColor = LxColors.grey350;

    final arrowIcon = (this.direction == PaymentDirection.Inbound)
        ? Icons.arrow_downward_rounded
        : Icons.arrow_upward_rounded;

    // const borderSide = BorderSide(color: iconColor, width: 2.0);

    return DecoratedBox(
      decoration: const BoxDecoration(
        color: LxColors.grey850,
        // TODO(phlip9): stroke border or filled circle?
        // border: Border(
        //   left: borderSide,
        //   top: borderSide,
        //   right: borderSide,
        //   bottom: borderSide,
        // ),
        borderRadius: BorderRadius.all(Radius.circular(1000.0)),
      ),
      child: SizedBox.square(
        dimension: 36.0,
        child: Icon(arrowIcon, size: Space.s500, color: iconColor),
      ),
    );
  }
}
