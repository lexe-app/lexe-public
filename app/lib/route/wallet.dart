// The primary wallet page.

import 'dart:async' show StreamController;

import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart' show freezed;
import 'package:intl/intl.dart' show NumberFormat;
import 'package:rxdart_ext/rxdart_ext.dart';

import '../../bindings_generated_api.dart'
    show
        AppHandle,
        BasicPayment,
        FiatRate,
        NodeInfo,
        PaymentDirection,
        PaymentKind,
        PaymentStatus;
import '../../date_format.dart' as date_format;
import '../../logger.dart' show error, info;
import '../../style.dart' show Fonts, LxColors, LxRadius, Space;

// Include code generated by @freezed
part 'wallet.freezed.dart';

class WalletPage extends StatefulWidget {
  const WalletPage({super.key, required this.app});

  final AppHandle app;

  @override
  WalletPageState createState() => WalletPageState();
}

class WalletPageState extends State<WalletPage> {
  /// A stream controller to trigger refreshes of the wallet page contents.
  final StreamController<Null> refresh = StreamController.broadcast();

  /// A stream controller to notify when some payments are updated.
  final StreamController<Null> paymentsUpdated = StreamController();

  // BehaviorSubject: a StreamController that captures the latest item added
  // to the controller, and emits that as the first item to any new listener.
  final BehaviorSubject<FiatRate?> fiatRate = BehaviorSubject.seeded(null);
  final BehaviorSubject<NodeInfo?> nodeInfos = BehaviorSubject.seeded(null);

  // StateSubject: like BehaviorSubject but only notifies subscribers if the
  // new item is actually different.
  final StateSubject<BalanceState> balanceStates =
      StateSubject(BalanceState.placeholder);

  @override
  void initState() {
    super.initState();

    final app = this.widget.app;

    // TODO(phlip9): get from user preferences
    const String fiatName = "USD";

    // A stream of `BalanceState`s that gets updated when `nodeInfos` or
    // `fiatRate` are updated. Since it's fed into a `StateSubject`, it also
    // avoids widget rebuilds if new state == old state.
    Rx.combineLatest2(
      this.nodeInfos.map((nodeInfo) => nodeInfo?.localBalanceMsat),
      this.fiatRate,
      (msatBalance, fiatRate) => BalanceState(
          msatsBalance: msatBalance, fiatName: fiatName, fiatRate: fiatRate),
    ).listen(this.balanceStates.addIfNotClosed);

    // A stream of refreshes, starting with an initial refresh.
    final Stream<Null> refreshRx = this.refresh.stream.startWith(null);

    // on refresh, update the current node info
    refreshRx.asyncMap((_) => app.nodeInfo()).listen(
          this.nodeInfos.addIfNotClosed,
          onError: (err) => error("nodeInfos: error: $err"),
        );

    // on refresh, update fiat rate
    refreshRx
        .asyncMap((_) => app.fiatRates())
        .map((fiatRates) =>
            fiatRates.rates.firstWhere((rate) => rate.fiat == fiatName))
        .listen(
          this.fiatRate.addIfNotClosed,
          onError: (err) => error("fiatRates: error: $err"),
        );

    // on refresh, sync payments from node
    refreshRx.asyncMap((_) => app.syncPayments()).listen(
      (anyChangedPayments) {
        info("syncPayments: anyChangedPayments: $anyChangedPayments");
        // Only re-render payments if they've actually changed.
        if (anyChangedPayments) {
          this.paymentsUpdated.addIfNotClosed(null);
        }
      },
      onError: (err) => error("syncPayments: error: $err"),
    );
  }

  @override
  void dispose() {
    this.refresh.close();
    this.paymentsUpdated.close();
    this.nodeInfos.close();
    this.fiatRate.close();
    this.balanceStates.close();

    super.dispose();
  }

  void triggerRefresh() {
    info("refresh triggered");
    this.refresh.addNull();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      extendBodyBehindAppBar: true,
      appBar: AppBar(
        automaticallyImplyLeading: false,

        // transparent bg header
        // TODO(phlip9): the action icons collide w/ the scrolled content. maybe
        // scroll this AppBar along with the content?
        backgroundColor: LxColors.clearB0,
        scrolledUnderElevation: 0.0,
        surfaceTintColor: LxColors.clearB0,

        // // header shadow effect
        // // not sure I like how this looks...
        // scrolledUnderElevation: 5.0,
        // shadowColor: LxColors.background,
        // surfaceTintColor: LxColors.clearB0,
        leading: Builder(
          builder: (context) => IconButton(
            iconSize: Fonts.size700,
            icon: const Icon(Icons.menu_rounded),
            onPressed: () => Scaffold.of(context).openDrawer(),
          ),
        ),
        actions: [
          IconButton(
            iconSize: Fonts.size700,
            icon: const Icon(Icons.refresh_rounded),
            onPressed: () => this.triggerRefresh(),
          ),
          const SizedBox(width: Space.s100),
        ],
      ),
      drawer: const WalletDrawer(),
      body: CustomScrollView(
        slivers: [
          // The primary wallet page content
          //
          // * Balance
          // * Wallet Actions (Fund, Receive, Send, ...)
          SliverToBoxAdapter(
              child: Column(children: [
            const SizedBox(height: Space.s1100),
            StateStreamBuilder(
              stream: this.balanceStates,
              builder: (context, balanceState) => BalanceWidget(balanceState),
            ),
            const SizedBox(height: Space.s700),
            const WalletActions(),
            const SizedBox(height: Space.s900),
          ])),

          // TODO(phlip9): It seems more useful to always show a separate
          // pending list, THEN show the completed/failed payments. When users
          // are looking at the primary page, they're far more likely to be
          // checking on some recent payment than looking at some old historical
          // payment.

          // The complete payments list
          StreamBuilder(
            stream: this.paymentsUpdated.stream,
            initialData: null,
            builder: (context, snapshot) => SliverPaymentsList(
              app: this.widget.app,
              // fiatRate: this.fiatRate.stream,
            ),
          )
        ],
      ),
      // TODO(phlip9): this default pull-to-refresh is really not great...
      // body: RefreshIndicator(
      //   backgroundColor: LxColors.background,
      //   color: LxColors.foreground,
      //   onRefresh: () async {
      //     refreshTx.add(null);
      //     await Future.delayed(const Duration(seconds: 1));
      //   },
      //   child: ListView(
      //     children: const [
      //       SizedBox(height: Space.s1000),
      //       BalanceWidget(),
      //       SizedBox(height: Space.s700),
      //       WalletActions(),
      //     ],
      //   ),
      // ),
    );
  }
}

typedef StateStreamWidgetBuilder<T> = Widget Function(
  BuildContext context,
  T data,
);

/// A small helper `Widget` that builds a new widget everytime a `StateStream`
/// gets an update.
///
/// This is slightly nicer than the standard `StreamBuilder` because
/// `StateStream`s always have an initial value and never error.
class StateStreamBuilder<T> extends StreamBuilder<T> {
  StateStreamBuilder({
    super.key,
    required StateStream<T> stream,
    required StateStreamWidgetBuilder builder,
  }) : super(
          stream: stream,
          initialData: stream.value,
          builder: (BuildContext context, AsyncSnapshot<T> snapshot) =>
              builder(context, snapshot.data),
        );
}

extension StreamControllerExt<T> on StreamController<T> {
  /// Calls `add(event)` as long as the `StreamController` is not already
  /// closed.
  void addIfNotClosed(T event) {
    if (!this.isClosed) {
      this.add(event);
    }
  }
}

class WalletDrawer extends StatelessWidget {
  const WalletDrawer({super.key});

  @override
  Widget build(BuildContext context) {
    final systemBarHeight = MediaQuery.of(context).padding.top;

    return Drawer(
      child: Padding(
        padding: EdgeInsets.only(top: systemBarHeight),
        child: ListView(
          padding: EdgeInsets.zero,
          children: [
            // X - close
            DrawerListItem(
              icon: Icons.close_rounded,
              onTap: () => Scaffold.of(context).closeDrawer(),
            ),
            const SizedBox(height: Space.s600),

            // * Settings
            // * Backup
            // * Security
            // * Support
            DrawerListItem(
              title: "Settings",
              icon: Icons.settings_outlined,
              onTap: () => info("settings pressed"),
            ),
            DrawerListItem(
              title: "Backup",
              icon: Icons.drive_file_move_outline,
              onTap: () => info("backup pressed"),
            ),
            DrawerListItem(
              title: "Security",
              icon: Icons.lock_outline_rounded,
              onTap: () => info("security pressed"),
            ),
            DrawerListItem(
              title: "Support",
              icon: Icons.help_outline_rounded,
              onTap: () => info("support pressed"),
            ),
            const SizedBox(height: Space.s600),

            // < Invite Friends >
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: Space.s500),
              child: OutlinedButton(
                style: OutlinedButton.styleFrom(
                  backgroundColor: LxColors.background,
                  foregroundColor: LxColors.foreground,
                  side:
                      const BorderSide(color: LxColors.foreground, width: 2.0),
                  padding: const EdgeInsets.symmetric(vertical: Space.s500),
                ),
                onPressed: () => info("invite pressed"),
                child: Text("Invite Friends",
                    style: Fonts.fontUI.copyWith(
                      fontSize: Fonts.size400,
                      fontVariations: [Fonts.weightMedium],
                    )),
              ),
            ),
            const SizedBox(height: Space.s600),

            // app version
            Text("Lexe App · v1.2.345",
                textAlign: TextAlign.center,
                style: Fonts.fontUI.copyWith(
                  color: LxColors.grey600,
                  fontSize: Fonts.size200,
                )),
          ],
        ),
      ),
    );
  }
}

class DrawerListItem extends StatelessWidget {
  const DrawerListItem({super.key, this.title, this.icon, this.onTap});

  final String? title;
  // final String? subtitle;
  final IconData? icon;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      contentPadding: const EdgeInsets.symmetric(horizontal: Space.s500),
      horizontalTitleGap: Space.s200,
      visualDensity: VisualDensity.standard,
      dense: false,
      leading: (this.icon != null)
          ? Icon(this.icon!, color: LxColors.foreground, size: Fonts.size700)
          : null,
      title: (this.title != null)
          ? Text(this.title!,
              style: Fonts.fontUI.copyWith(
                fontSize: Fonts.size400,
                fontVariations: [Fonts.weightMedium],
              ))
          : null,
      // subtitle: (this.subtitle != null)
      //     ? Text(this.subtitle!,
      //         style: Fonts.fontUI
      //             .copyWith(fontSize: Fonts.size300, color: LxColors.grey600))
      //     : null,
      onTap: this.onTap,
    );
  }
}

// TODO(phlip9): move these currency formatting fns

final NumberFormat integerFormatter =
    NumberFormat.decimalPatternDigits(decimalDigits: 0);

String directionToSign(PaymentDirection direction) =>
    (direction == PaymentDirection.Inbound) ? "+" : "-";

String formatSats(
  double sats, {
  PaymentDirection? direction,
  bool satsSuffix = true,
}) {
  final sign = (direction != null) ? directionToSign(direction) : "";

  final suffix = (satsSuffix) ? " sats" : "";

  return "$sign${integerFormatter.format(sats)}$suffix";
}

double msatsToSats(int msats) => msats * 1e-3;
double msatsToBtc(int msats) => msats * 1e-11;
double satsToBtc(int sats) => sats * 1e-8;

@freezed
class BalanceState with _$BalanceState {
  const factory BalanceState({
    required int? msatsBalance,
    required String fiatName,
    required FiatRate? fiatRate,
  }) = _BalanceState;

  const BalanceState._();

  static BalanceState placeholder =
      const BalanceState(msatsBalance: null, fiatName: "USD", fiatRate: null);

  double? fiatBalance() => (this.msatsBalance != null && this.fiatRate != null)
      ? msatsToBtc(this.msatsBalance!) * this.fiatRate!.rate
      : null;
}

class BalanceWidget extends StatelessWidget {
  const BalanceWidget(this.state, {super.key});

  final BalanceState state;

  @override
  Widget build(BuildContext context) {
    const satsBalanceSize = Fonts.size300;
    final satsBalanceOrPlaceholder = (this.state.msatsBalance != null)
        ? Text(
            formatSats(msatsToSats(this.state.msatsBalance!)),
            style: Fonts.fontUI.copyWith(
              fontSize: satsBalanceSize,
              color: LxColors.grey700,
              fontVariations: [Fonts.weightMedium],
            ),
          )
        : const FilledPlaceholder(
            width: Space.s1000,
            height: satsBalanceSize,
            forText: true,
          );

    final fiatBalance = this.state.fiatBalance();
    final fiatBalanceOrPlaceholder = (fiatBalance != null)
        ? PrimaryBalanceText(
            fiatBalance: fiatBalance,
            fiatName: this.state.fiatRate!.fiat,
          )
        : const FilledPlaceholder(
            width: Space.s1100,
            height: Fonts.size800,
            forText: true,
          );

    return Column(
      children: [
        fiatBalanceOrPlaceholder,
        const SizedBox(height: Space.s400),
        satsBalanceOrPlaceholder,
      ],
    );
  }
}

/// A simple colored box that we can show while some real content is loading.
///
/// The `width` and `height` are optional. If left `null`, that dimension will
/// be determined by the parent `Widget`'s constraints.
///
/// If the placeholder is replacing some text, `forText` should be set to `true`.
/// This is because a `Text` widget's actual rendered height also depends on the
/// current `MediaQuery.textScaleFactor`.
class FilledPlaceholder extends StatelessWidget {
  const FilledPlaceholder({
    super.key,
    this.color = LxColors.grey850,
    this.width = double.infinity,
    this.height = double.infinity,
    this.borderRadius = LxRadius.r200,
    this.forText = false,
    this.child,
  });

  final Color color;
  final double width;
  final double height;
  final double borderRadius;
  final bool forText;
  final Widget? child;

  @override
  Widget build(BuildContext context) {
    final double heightFactor;
    if (!this.forText) {
      heightFactor = 1.0;
    } else {
      heightFactor = MediaQuery.of(context).textScaleFactor;
    }

    return SizedBox(
      width: this.width,
      height: this.height * heightFactor,
      child: DecoratedBox(
        decoration: BoxDecoration(
          color: this.color,
          borderRadius: BorderRadius.circular(this.borderRadius),
        ),
        child: this.child,
      ),
    );
  }
}

class PrimaryBalanceText extends StatelessWidget {
  const PrimaryBalanceText({
    super.key,
    required this.fiatBalance,
    required this.fiatName,
  });

  final double fiatBalance;
  final String fiatName;

  @override
  Widget build(BuildContext context) {
    final NumberFormat currencyFormatter = NumberFormat.simpleCurrency(
      name: this.fiatName,
    );
    final fiatBalanceStr = currencyFormatter.format(this.fiatBalance);

    final decimalSeparator = currencyFormatter.symbols.DECIMAL_SEP;
    final maybeDecimalIdx = fiatBalanceStr.lastIndexOf(decimalSeparator);

    // ex: fiatBalance = 123.45679
    //     fiatBalanceSignificant = "$123"
    //     fiatBalanceFractional = ".46"
    final String fiatBalanceSignificant;
    final String? fiatBalanceFractional;

    if (maybeDecimalIdx >= 0) {
      fiatBalanceSignificant = fiatBalanceStr.substring(0, maybeDecimalIdx);
      fiatBalanceFractional = fiatBalanceStr.substring(maybeDecimalIdx);
    } else {
      fiatBalanceSignificant = fiatBalanceStr;
      fiatBalanceFractional = null;
    }

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          fiatBalanceSignificant,
          style: Fonts.fontUI.copyWith(
            fontSize: Fonts.size800,
            fontVariations: [Fonts.weightMedium],
          ),
        ),
        if (fiatBalanceFractional != null)
          Text(
            fiatBalanceFractional,
            style: Fonts.fontUI.copyWith(
              fontSize: Fonts.size800,
              color: LxColors.fgTertiary,
              fontVariations: [Fonts.weightMedium],
            ),
          ),
      ],
    );
  }
}

class WalletActions extends StatelessWidget {
  const WalletActions({super.key});

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        const WalletActionButton(
          onPressed: null,
          icon: Icons.add_rounded,
          label: "Fund",
        ),
        const SizedBox(width: Space.s400),
        WalletActionButton(
          onPressed: () => info("recv pressed"),
          icon: Icons.arrow_downward_rounded,
          label: "Receive",
        ),
        const SizedBox(width: Space.s400),
        WalletActionButton(
          onPressed: () => info("send pressed"),
          icon: Icons.arrow_upward_rounded,
          label: "Send",
        ),
      ],
    );
  }
}

class WalletActionButton extends StatelessWidget {
  const WalletActionButton({
    super.key,
    required this.onPressed,
    required this.icon,
    required this.label,
  });

  final VoidCallback? onPressed;
  final IconData icon;
  final String label;

  @override
  Widget build(BuildContext context) {
    final bool isDisabled = (this.onPressed == null);

    return Column(
      children: [
        FilledButton(
          onPressed: this.onPressed,
          style: FilledButton.styleFrom(
            backgroundColor: LxColors.grey975,
            disabledBackgroundColor: LxColors.grey850,
            foregroundColor: LxColors.foreground,
            disabledForegroundColor: LxColors.grey725,
          ),
          child: Padding(
            padding: const EdgeInsets.all(Space.s400),
            child: Icon(this.icon, size: Fonts.size700),
          ),
        ),
        const SizedBox(height: Space.s400),
        Text(
          label,
          style: Fonts.fontUI.copyWith(
            fontSize: Fonts.size300,
            color: (!isDisabled) ? LxColors.foreground : LxColors.grey725,
            fontVariations: [Fonts.weightSemiBold],
          ),
        ),
      ],
    );
  }
}

class SliverPaymentsList extends StatelessWidget {
  const SliverPaymentsList({super.key, required this.app});

  final AppHandle app;

  @override
  Widget build(BuildContext context) {
    final numPayments = this.app.getNumPayments();
    info("build SliverPaymentsList: numPayments: $numPayments");

    // TODO(phlip9): also investigate more efficient `SliverFixedExtentList`,
    // since each payment list entry should be the same height?
    return SliverList(
        delegate: SliverChildBuilderDelegate(
      (context, scrollIdx) {
        final payment = this.app.getPaymentByScrollIdx(scrollIdx: scrollIdx);

        if (payment != null) {
          // final amount = payment.
          return PaymentsListEntry(
            payment: payment,
            // fiatRate: this.fiatRate,
          );
        } else {
          return null;
        }
      },
      childCount: numPayments,
      // findChildIndexCallback: (Key childKey) => this.app.getPaymentScrollIdxByPaymentId(childKey),
    ));
  }
}

String formatFiatValue({
  required FiatRate? rate,
  required int? amountSats,
  required PaymentDirection direction,
}) {
  if (rate == null || amountSats == null) {
    return "";
  }

  final fiatValue = satsToBtc(amountSats) * rate.rate;
  final sign = directionToSign(direction);

  final NumberFormat currencyFormatter =
      NumberFormat.simpleCurrency(name: rate.fiat);
  return "$sign${currencyFormatter.format(fiatValue)}";
}

class PaymentsListEntry extends StatelessWidget {
  PaymentsListEntry({required this.payment}) : super(key: Key(payment.index));

  final BasicPayment payment;

  @override
  Widget build(BuildContext context) {
    final status = this.payment.status;
    final direction = this.payment.direction;
    final kind = this.payment.kind;
    final amountSats = this.payment.amountSat;
    final note = this.payment.note;

    final leadingIcon = PaymentListIcon(kind: kind);

    // TODO(phlip9): figure out a heuristic to get the counterparty name.
    final String primaryStr;
    if (status == PaymentStatus.Pending) {
      if (direction == PaymentDirection.Inbound) {
        primaryStr = "Receiving payment";
      } else {
        primaryStr = "Sending payment";
      }
    } else {
      if (direction == PaymentDirection.Inbound) {
        primaryStr = "You received";
      } else {
        primaryStr = "You sent";
      }
    }

    // ex: "Receiving payment" (pending, inbound)
    // ex: "Sending payment" (pending, outbound)
    // ex: "You received" (finalized, inbound)
    // ex: "You sent" (finalized, outbound)
    final primaryText = Text(
      primaryStr,
      maxLines: 1,
      style: Fonts.fontUI.copyWith(
        fontSize: Fonts.size300,
        color: LxColors.fgSecondary,
        fontVariations: [Fonts.weightMedium],
      ),
    );

    // TODO(phlip9): display as BTC rather than sats depending on user
    //               preferences.
    // the weird unicode thing that isn't rendering is the BTC B currency symbol
    // "+₿0.00001230",

    const primaryValueWidth = Space.s1000;

    final Color primaryValueColor;
    if (direction == PaymentDirection.Inbound &&
        status != PaymentStatus.Failed) {
      primaryValueColor = LxColors.moneyGoUp;
    } else {
      primaryValueColor = LxColors.fgSecondary;
    }

    final String amountSatsStr = (amountSats != null)
        ? formatSats(amountSats.toDouble(),
            direction: direction, satsSuffix: true)
        : "";

    // ex: "" (certain niche cases w/ failed or pending LN invoice payments)
    // ex: "+45,000 sats"
    // ex: "-128 sats"
    final primaryValueText = Text(
      amountSatsStr,
      maxLines: 1,
      textAlign: TextAlign.end,
      style: Fonts.fontUI.copyWith(
        fontSize: Fonts.size200,
        color: primaryValueColor,
      ),
    );

    // ex: "Failed" (payment failed, no note)
    // ex: "Brunch with friends" (note only)
    // ex: "Failed · Funds from Boincase" (failed + note)
    final secondaryText = RichText(
      text: TextSpan(
        text: null,
        children: <TextSpan>[
          // prefix with "Failed" to indicate problem w/ payment.
          if (status == PaymentStatus.Failed)
            const TextSpan(
              text: "Failed",
              style: TextStyle(
                color: LxColors.errorText,
                // fontVariations: [Fonts.weightMedium],
              ),
            ),
          // separator should only show if both sides are present
          if (status == PaymentStatus.Failed && note != null)
            const TextSpan(text: " · "),
          if (note != null) TextSpan(text: note)
        ],
        style: Fonts.fontUI.copyWith(
          fontSize: Fonts.size200,
          color: LxColors.fgTertiary,
        ),
      ),
      maxLines: 1,
      overflow: TextOverflow.ellipsis,
    );

    const secondaryDateWidth = Space.s850;
    final createdAt = DateTime.fromMillisecondsSinceEpoch(payment.createdAt);
    final createdAtStr = date_format.formatDateCompact(then: createdAt);

    // ex: "10min"
    // ex: "Jun 16"
    // ex: "14h"
    final secondaryDateText = Text(
      createdAtStr ?? "",
      maxLines: 1,
      textAlign: TextAlign.end,
      style: Fonts.fontUI.copyWith(
        fontSize: Fonts.size200,
        color: LxColors.fgTertiary,
      ),
    );

    return ListTile(
      // list tile styling

      contentPadding: const EdgeInsets.symmetric(
        horizontal: Space.s400,
        vertical: Space.s0,
      ),
      horizontalTitleGap: Space.s200,
      visualDensity: VisualDensity.standard,
      dense: false,

      // actual content

      leading: leadingIcon,

      // NOTE: we use a Row() in `title` and `subtitle` instead of `trailing` so
      // that the text baselines to align properly.

      title: Row(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.baseline,
        textBaseline: TextBaseline.alphabetic,
        children: [
          Expanded(
            child: primaryText,
          ),
          SizedBox(
            width: primaryValueWidth,
            child: primaryValueText,
          ),
        ],
      ),

      subtitle: Row(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.baseline,
        textBaseline: TextBaseline.alphabetic,
        children: [
          Expanded(
            child: secondaryText,
          ),
          SizedBox(
            width: secondaryDateWidth,
            child: secondaryDateText,
          ),
        ],
      ),
    );
  }
}

class PaymentListIcon extends StatelessWidget {
  const PaymentListIcon({
    super.key,
    required this.kind,
  });

  final PaymentKind kind;

  @override
  Widget build(BuildContext context) {
    final icon = (this.kind == PaymentKind.Onchain)
        ? Icons.currency_bitcoin_rounded
        : Icons.bolt_rounded;

    // const borderSide = BorderSide(color: iconColor, width: 2.0);

    return DecoratedBox(
      decoration: const BoxDecoration(
        color: LxColors.grey850,
        // TODO(phlip9): stroke border or filled circle?
        // border: Border(
        //   left: borderSide,
        //   top: borderSide,
        //   right: borderSide,
        //   bottom: borderSide,
        // ),
        borderRadius: BorderRadius.all(Radius.circular(1000.0)),
      ),
      child: SizedBox.square(
        dimension: 36.0,
        child: Icon(
          icon,
          size: Space.s500,
          color: LxColors.fgSecondary,
        ),
      ),
    );
  }
}
