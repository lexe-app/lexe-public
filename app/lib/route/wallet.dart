// The primary wallet page.

import 'dart:async'
    show
        StreamController,
        StreamSubscription,
        TimeoutException,
        Timer,
        unawaited;

import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart' show freezed;
import 'package:intl/intl.dart' show NumberFormat;
import 'package:lexeapp/components.dart'
    show
        FilledPlaceholder,
        LxOutlinedButton,
        LxRefreshButton,
        MultistepFlow,
        StateStreamBuilder,
        showModalAsyncFlow;
import 'package:lexeapp/currency_format.dart' as currency_format;
import 'package:lexeapp/date_format.dart' as date_format;
import 'package:lexeapp/ffi/ffi_generated_api.dart'
    show
        AppHandle,
        Config,
        DeployEnv,
        FiatRate,
        FiatRates,
        NodeInfo,
        PaymentDirection,
        PaymentKind,
        PaymentStatus,
        ShortPayment,
        ShortPaymentAndIndex;
import 'package:lexeapp/ffi/ffi_generated_api_ext.dart' show ClientPaymentIdExt;
import 'package:lexeapp/logger.dart';
import 'package:lexeapp/result.dart';
import 'package:lexeapp/route/debug.dart' show DebugPage;
import 'package:lexeapp/route/payment_detail.dart' show PaymentDetailPage;
import 'package:lexeapp/route/receive.dart' show ReceivePaymentPage;
import 'package:lexeapp/route/scan.dart';
import 'package:lexeapp/route/send/page.dart' show SendPaymentPage;
import 'package:lexeapp/route/send/state.dart'
    show SendFlowResult, SendState, SendState_NeedUri;
import 'package:lexeapp/stream_ext.dart';
import 'package:lexeapp/style.dart' show Fonts, LxColors, LxIcons, Space;
import 'package:lexeapp/uri_events.dart' show UriEvents;
import 'package:rxdart_ext/rxdart_ext.dart';

// Include code generated by @freezed
part 'wallet.freezed.dart';

class WalletPage extends StatefulWidget {
  const WalletPage({
    super.key,
    required this.config,
    required this.app,
    required this.uriEvents,
  });

  final Config config;
  final AppHandle app;
  final UriEvents uriEvents;

  @override
  WalletPageState createState() => WalletPageState();
}

class WalletPageState extends State<WalletPage> {
  final GlobalKey<ScaffoldState> scaffoldKey = GlobalKey();

  /// A timer calls `this.triggerRefresh` every ~1 min of _inactivity_, so the
  /// balance, fiat rates, etc... stay somewhat up-to-date while the app is
  /// open.
  Timer? backgroundRefresh;

  /// After just sending a Lightning payment, we'll burst refresh for a moment
  /// to try and catch the payment completing. Bitcoin payments take a while
  /// to confirm, so there's no point polling harder.
  final StreamController<Null> burstRefresh = StreamController();
  bool isBurstRefreshing = false;

  /// A stream controller to trigger refreshes of the wallet page contents.
  final StreamController<Null> refresh = StreamController.broadcast();

  /// Listen to this stream to be notified of the next completed refresh.
  final StreamController<Null> onCompletedRefresh =
      StreamController.broadcast();

  /// True if there's currently an outstanding refresh.
  final ValueNotifier<bool> isRefreshing = ValueNotifier(false);

  /// A stream controller to notify when some payments are updated.
  final StreamController<Null> paymentsUpdated = StreamController.broadcast();

  // BehaviorSubject: a StreamController that captures the latest item added
  // to the controller, and emits that as the first item to any new listener.
  final BehaviorSubject<FiatRate?> fiatRate = BehaviorSubject.seeded(null);
  final BehaviorSubject<NodeInfo?> nodeInfos = BehaviorSubject.seeded(null);

  // StateSubject: like BehaviorSubject but only notifies subscribers if the
  // new item is actually different.
  final StateSubject<BalanceState> balanceStates =
      StateSubject(BalanceState.placeholder);

  /// The wallet page listens to URI events.
  late StreamSubscription<String> uriEventsListener;

  // TODO(phlip9): get from user preferences
  final String fiatPreference = "USD";
  // final String fiatPreference = "EUR";

  @override
  void initState() {
    super.initState();

    // Calls `this.onRefresh` when we get a new refresh (and always once at
    // page open). Refreshes are also throttled and won't trigger while a
    // a previous refresh is pending.
    this
        .refresh
        .stream
        // ignore `triggerRefresh` if we're currently refreshing.
        .where((_) => !this.isRefreshing.value)
        // but unconditionally start with an initial "refresh" to load node
        // state.
        .startWith(null)
        // ignore multiple refreshes if the we trigger again within 3 secs.
        .throttleTime(const Duration(seconds: 3))
        .log(id: "refresh start")
        // ok we're actually refreshing for real this time! do some bookkeeping
        // and send some requests.
        .listen(this.onRefresh);

    // Kick off the initial background refresh tick (happens every 1 min of
    // inactivity).
    this.resetBackgroundRefreshTimer();

    // Burst refresher (2 sec, 6 sec, 15 sec) after e.g. sending a payment and
    // polling for its status.
    this
        .burstRefresh
        .stream
        // TODO(phlip9): reset burst refresh instead of skipping?
        .where((_) => !this.isBurstRefreshing)
        .log(id: "burst refresh start")
        .listen(this.onBurstRefresh);

    // A stream of `BalanceState`s that gets updated when `nodeInfos` or
    // `fiatRate` are updated. Since it's fed into a `StateSubject`, it also
    // avoids widget rebuilds if new state == old state.
    Rx.combineLatest2(
      this.nodeInfos.map((nodeInfo) => nodeInfo?.balance.totalSats),
      this.fiatRate,
      (balanceSats, fiatRate) => BalanceState(
        balanceSats: balanceSats,
        fiatName: this.fiatPreference,
        fiatRate: fiatRate,
      ),
    ).listen(this.balanceStates.addIfNotClosed);

    // Listen to platform URI events (e.g., user taps a "lightning:" URI in
    // their browser).
    this.uriEventsListener =
        this.widget.uriEvents.uriStream.listen(this.onUriEvent);
  }

  @override
  void dispose() {
    this.backgroundRefresh?.cancel();
    this.burstRefresh.close();
    this.refresh.close();
    this.onCompletedRefresh.close();
    this.isRefreshing.dispose();
    this.paymentsUpdated.close();
    this.nodeInfos.close();
    this.fiatRate.close();
    this.balanceStates.close();
    this.uriEventsListener.cancel();

    super.dispose();
  }

  /// User triggers a refresh (fetch balance, fiat rates, payment sync).
  /// NOTE: the refresh stream is throttled to max every 3 sec.
  void triggerRefresh() => this.refresh.addIfNotClosed(null);

  /// On refresh, resync state from the node.
  Future<void> onRefresh(Null n) async {
    this.isRefreshing.value = true;

    // First, let's reset the background timer. If e.g. the user just hit the
    // refresh button, we won't needlessly background refresh early.
    this.resetBackgroundRefreshTimer();

    // Actually resync the state.
    await (fetchNodeInfo(), fetchFiatRates(), syncPayments()).wait;

    if (!this.mounted) return;

    this.onCompletedRefresh.addIfNotClosed(null);
    this.isRefreshing.value = false;
  }

  /// Cancel the current background timer and set a new one a minute from now.
  /// This way, if the user hits the refresh button or a burst refresh is
  /// triggered, the background refresh will get delayed until the next period
  /// of inactivity.
  void resetBackgroundRefreshTimer() {
    this.backgroundRefresh?.cancel();

    // TODO(phlip9): once we get push notifications working, we can perhaps
    // remove this or only background refresh for the first ~10 min. Then rely
    // on push notification to tell us to start polling again.
    this.backgroundRefresh = Timer(
      const Duration(minutes: 1),
      () {
        info("background refresh timer tick");
        this.triggerRefresh();
      },
    );
  }

  /// Start a new burst refresh.
  void triggerBurstRefresh() => this.burstRefresh.addNull();

  /// Call [this.triggerRefresh] in rapid succession after we e.g. send a
  /// payment and want to quickly poll its status as it updates.
  Future<void> onBurstRefresh(Null n) async {
    this.isBurstRefreshing = true;

    const delays = [
      Duration(seconds: 3),
      Duration(seconds: 6),
      Duration(seconds: 9)
    ];

    for (final delay in delays) {
      await Future.delayed(delay);
      if (!this.mounted) return;

      info("burst refresh timer tick");
      this.triggerRefresh();
    }

    this.isBurstRefreshing = false;
  }

  Future<void> fetchNodeInfo() async {
    final res = await Result.tryFfiAsync(this.widget.app.nodeInfo);
    switch (res) {
      case Ok(:final ok):
        info("nodeInfo: $ok");
        this.nodeInfos.addIfNotClosed(ok);
        return;
      case Err(:final err):
        error("Failed to fetch nodeInfo: $err");
        return;
    }
  }

  Future<void> fetchFiatRates() async {
    final res = await Result.tryFfiAsync(this.widget.app.fiatRates);

    final FiatRates fiatRates;
    switch (res) {
      case Ok(:final ok):
        info("fiatRates: $ok");
        fiatRates = ok;
      case Err(:final err):
        error("Failed to fetch fiatRates: $err");
        return;
    }

    // Select just fiat rate for user's current preferred fiat currency
    final fiatRate =
        fiatRates.rates.firstWhere((rate) => rate.fiat == this.fiatPreference);
    info("fiatRate: $fiatRate, timestampMs: ${fiatRates.timestampMs}");

    this.fiatRate.addIfNotClosed(fiatRate);
  }

  Future<void> syncPayments() async {
    final res = await Result.tryFfiAsync(this.widget.app.syncPayments);

    final bool anyChangedPayments;
    switch (res) {
      case Ok(:final ok):
        info("syncPayments: any changed: $ok");
        anyChangedPayments = ok;
      case Err(:final err):
        error("Failed to syncPayments: $err");
        return;
    }

    // Only re-render payments if they've actually changed.
    if (anyChangedPayments) {
      this.paymentsUpdated.addIfNotClosed(null);
    }
  }

  /// When a user taps a payment URI (ex: "lightning:") in another app/browser,
  /// and chooses Lexe to handle it, we'll try to open a new send flow to handle
  /// it.
  Future<void> onUriEvent(String uri) async {
    // TODO(phlip9): one issue here is: what to do if we get _another_ payment
    // URI while we're already mid send flow? Probably the right thing to do is
    // ask the user if they want to interrupt their current flow, and then
    // replace the current flow with a new flow if they agree.

    // For now, just queue up events while we're already handling one.
    this.uriEventsListener.pause();

    try {
      info("WalletPage: uriEvent: $uri");

      // Wait for NodeInfo to be available (if not already) and try to preflight
      // this send payment URI, showing a modal loading widget.
      final result = await this._onUriEventPreflight(uri);
      info("WalletPage: uriEvent: preflight result: $result");
      if (!this.mounted || result == null || result.isErr) return;

      // If the user successfully sent a payment, we'll get the new payment's
      // `PaymentIndex` from the flow. O/w canceling the flow will give us `null`.
      final SendFlowResult? flowResult =
          await Navigator.of(this.context).push(MaterialPageRoute(
        builder: (context) =>
            SendPaymentPage(sendCtx: result.unwrap(), startNewFlow: true),
      ));

      info("WalletPage: uriEvent: flowResult: $flowResult");

      // User canceled
      if (!this.mounted || flowResult == null) return;

      // Refresh and open new payment detail
      await this.onSendFlowSuccess(flowResult);
    } finally {
      this.uriEventsListener.resume();
    }
  }

  /// Try to preflight a send payment URI, showing a spinner while it's loading
  /// and an error modal if it fails.
  Future<Result<SendState, String>?> _onUriEventPreflight(String uri) async {
    // We could be cold starting (the user wants Lexe to make a payment from
    // another app, but Lexe isn't already running, so it needs to startup
    // cold).
    //
    // In such a case, we'll need to wait (with a timeout) for our connection to
    // the node to go through so we can get our balance.
    final result = await this.collectSendContext();

    // Canceled or timedout
    if (!this.mounted || result.isErr) return null;

    final sendCtx = result.unwrap();
    return showModalAsyncFlow(
      context: this.context,
      future: sendCtx.resolveAndMaybePreflight(uri),
      // TODO(phlip9): error messages need work
      errorBuilder: (context, err) => AlertDialog(
        title: const Text("Issue with payment"),
        content: Text(err),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text("Close"),
          ),
        ],
      ),
    );
  }

  void openScaffoldDrawer() {
    this.scaffoldKey.currentState?.openDrawer();
  }

  /// Called when the "Receive" button is pressed. Pushes the receive payment
  /// page onto the navigation stack.
  Future<void> onReceivePressed() async {
    // TODO(phlip9): remove this temporary hack once the recv UI gets build
    final result = await Result.tryFfiAsync(() => this.widget.app.getAddress());
    info("getAddress => $result");

    if (!this.mounted) return;

    unawaited(Navigator.of(this.context).push(
      MaterialPageRoute(
        builder: (context) => ReceivePaymentPage(
          app: this.widget.app,
          fiatRate: this.fiatRate.stream,
        ),
      ),
    ));
  }

  /// Called when the "Send" button is pressed. Pushes the send payment page
  /// onto the navigation stack.
  Future<void> onSendPressed() async {
    final sendCtx = this.tryCollectSendContext();
    if (sendCtx == null) return;

    // If the user successfully sent a payment, we'll get the new payment's
    // `PaymentIndex` from the flow. O/w canceling the flow will give us `null`.
    final SendFlowResult? flowResult =
        await Navigator.of(this.context).push(MaterialPageRoute(
      builder: (context) =>
          SendPaymentPage(sendCtx: sendCtx, startNewFlow: true),
    ));

    info("WalletPage: onSendPressed: flowResult: $flowResult");

    // User canceled
    if (!this.mounted || flowResult == null) return;

    // Refresh and open new payment detail
    await this.onSendFlowSuccess(flowResult);
  }

  /// Called when the "Scan" button is pressed. Pushes the QR scan page onto the
  /// navigation stack.
  Future<void> onScanPressed() async {
    final sendCtx = this.tryCollectSendContext();
    if (sendCtx == null) return;

    // If the user successfully sent a payment, we'll get the new payment's
    // `PaymentIndex` from the flow. O/w canceling the flow will give us `null`.
    //
    // Note: this is inside a MultistepFlow so "back" goes back a step while
    // "close" exits the flow to this page again.
    final SendFlowResult? flowResult =
        await Navigator.of(this.context).push(MaterialPageRoute(
      builder: (_context) => MultistepFlow<SendFlowResult>(
        builder: (_context) => ScanPage(sendCtx: sendCtx),
      ),
    ));
    info("WalletPage: onScanPressed: flowResult: $flowResult");

    // User canceled
    if (!this.mounted || flowResult == null) return;

    // Refresh and open new payment detail
    await this.onSendFlowSuccess(flowResult);
  }

  /// Collect up all the relevant context needed to support a new send payment
  /// flow, and wait until it's available if it's not already immediately
  /// available.
  Future<Result<SendState_NeedUri, TimeoutException>>
      collectSendContext() async {
    final result = await Result.tryAsync<NodeInfo, TimeoutException>(
      () => this
          .nodeInfos
          .stream
          .whereNotNull()
          .first
          .timeout(const Duration(seconds: 15)),
    );
    return result.map((_) => this.tryCollectSendContext()!);
  }

  /// Collect up all the relevant context needed to support a new send payment
  /// flow.
  SendState_NeedUri? tryCollectSendContext() {
    final maybeNodeInfo = this.nodeInfos.value;
    // Ignore Send/Scan button press, we haven't fetched the node info yet.
    if (maybeNodeInfo == null) return null;

    final balance = maybeNodeInfo.balance;
    return SendState_NeedUri(
      app: this.widget.app,
      configNetwork: this.widget.config.network,
      balance: balance,
      cid: ClientPaymentIdExt.generate(),
    );
  }

  /// Called after the user has successfully sent a new payment and the send
  /// flow has popped back to the wallet page. We'll trigger a refresh, wait
  /// for the next payments sync, then open the payment detail page for the
  /// new page.
  ///
  /// For lightning payments, we'll also start burst refreshing, so we can
  /// quickly pick up any status changes.
  Future<void> onSendFlowSuccess(SendFlowResult flowResult) async {
    // Add a waiter for the next completed refresh tick, with a timeout.
    final nextCompletedRefresh = Result.tryAsync<Null, Exception>(
      () => this
          .onCompletedRefresh
          .stream
          .first
          .timeout(const Duration(seconds: 10)),
    );

    // Actually trigger a refresh. May be ignored, if throttled, in which case
    // timeout should clean things up.
    this.triggerRefresh();

    // Wait for next completed refresh.
    switch (await nextCompletedRefresh) {
      case Ok():
        info("WalletPage: onSendFlowSuccess: refresh completed");

      case Err(:final err):
        warn(
            "WalletPage: onSendFlowSuccess: error waiting for next completed refresh: $err");
        return;
    }

    // Lightning payments actually have a chance to finalize in the next few
    // seconds, so start a burst refresh.
    switch (flowResult.kind) {
      case PaymentKind.Invoice || PaymentKind.Spontaneous:
        this.triggerBurstRefresh();
      case PaymentKind.Onchain:
      // do nothing.
    }

    // Now lookup the new payment in our freshly synced local db.
    final maybeVecIdx = await this
        .widget
        .app
        .getVecIdxByPaymentIndex(paymentIndex: flowResult.index);

    if (maybeVecIdx == null) {
      warn(
          "WalletPage: onSendFlowSuccess: failed to find payment index after refresh: index: $flowResult.index");
      return;
    }

    // Open the payment detail page to this payment.
    this.onPaymentTap(maybeVecIdx);
  }

  /// Called when one of the payments in the [SliverPaymentsList] is tapped.
  void onPaymentTap(int paymentVecIdx) {
    Navigator.of(this.context).push(MaterialPageRoute(
      builder: (context) => PaymentDetailPage(
        app: this.widget.app,
        paymentVecIdx: paymentVecIdx,
        paymentsUpdated: this.paymentsUpdated.stream,
        fiatRate: this.fiatRate.stream,
        isRefreshing: this.isRefreshing,
        triggerRefresh: this.triggerRefresh,
      ),
    ));
  }

  void onDebugPressed() {
    Navigator.of(this.context).push(MaterialPageRoute(
      builder: (context) => DebugPage(
        config: this.widget.config,
        app: this.widget.app,
      ),
    ));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      key: this.scaffoldKey,
      extendBodyBehindAppBar: true,
      appBar: AppBar(
        // ≡ - Open navigation drawer on the left
        leading: IconButton(
          icon: const Icon(LxIcons.menu),
          onPressed: this.openScaffoldDrawer,
        ),

        // ⟳ - Trigger refresh of current balance, payments, etc...
        actions: [
          LxRefreshButton(
            isRefreshing: this.isRefreshing,
            triggerRefresh: this.triggerRefresh,
          ),
          const SizedBox(width: Space.s100),
        ],
      ),
      drawer: WalletDrawer(
        config: this.widget.config,
        onDebugPressed: this.onDebugPressed,
      ),
      body: CustomScrollView(
        slivers: [
          // The primary wallet page content
          //
          // * Balance
          // * Wallet Actions (Fund, Receive, Send, ...)
          SliverToBoxAdapter(
              child: Column(children: [
            const SizedBox(height: Space.s1100),
            StateStreamBuilder(
              stream: this.balanceStates,
              builder: (context, balanceState) => BalanceWidget(balanceState),
            ),
            const SizedBox(height: Space.s700),
            WalletActions(
              // ☐ - Quickly scan a QR code
              onScanPressed: this.onScanPressed,
              // ↓ - Open BTC/LN receive payment page
              onReceivePressed: this.onReceivePressed,
              // ↑ - Open BTC/LN send payment page
              onSendPressed: this.onSendPressed,
            ),
            const SizedBox(height: Space.s800),
          ])),

          // Pending payments && not junk + header
          StreamBuilder(
            stream: this.paymentsUpdated.stream,
            initialData: null,
            builder: (context, snapshot) => SliverPaymentsList(
              app: this.widget.app,
              filter: PaymentsListFilter.pendingNotJunk,
              onPaymentTap: this.onPaymentTap,
            ),
          ),

          // Completed+Failed && not junk payments + header
          StreamBuilder(
            stream: this.paymentsUpdated.stream,
            initialData: null,
            builder: (context, snapshot) => SliverPaymentsList(
              app: this.widget.app,
              filter: PaymentsListFilter.finalizedNotJunk,
              onPaymentTap: this.onPaymentTap,
            ),
          )
        ],
      ),
    );
  }
}

class WalletDrawer extends StatelessWidget {
  const WalletDrawer({
    super.key,
    required this.config,
    this.onSettingsPressed,
    this.onBackupPressed,
    this.onSecurityPressed,
    this.onSupportPressed,
    this.onDebugPressed,
    this.onInvitePressed,
  });

  final Config config;

  final VoidCallback? onSettingsPressed;
  final VoidCallback? onBackupPressed;
  final VoidCallback? onSecurityPressed;
  final VoidCallback? onSupportPressed;
  final VoidCallback? onDebugPressed;
  final VoidCallback? onInvitePressed;

  @override
  Widget build(BuildContext context) {
    final systemBarHeight = MediaQuery.of(context).padding.top;

    return Drawer(
      child: Padding(
        padding: EdgeInsets.only(top: systemBarHeight),
        child: ListView(
          padding: EdgeInsets.zero,
          children: [
            // X - close
            DrawerListItem(
              icon: LxIcons.close,
              onTap: () => Scaffold.of(context).closeDrawer(),
            ),
            const SizedBox(height: Space.s600),

            // * Settings
            // * Backup
            // * Security
            // * Support
            DrawerListItem(
              title: "Settings",
              icon: LxIcons.settings,
              onTap: this.onSettingsPressed,
            ),
            DrawerListItem(
              title: "Backup",
              icon: LxIcons.backup,
              onTap: this.onBackupPressed,
            ),
            DrawerListItem(
              title: "Security",
              icon: LxIcons.security,
              onTap: this.onSecurityPressed,
            ),
            DrawerListItem(
              title: "Support",
              icon: LxIcons.support,
              onTap: this.onSupportPressed,
            ),

            // Don't show debugging menu in prod
            if (config.deployEnv == DeployEnv.Dev ||
                config.deployEnv == DeployEnv.Staging)
              DrawerListItem(
                title: "Debug",
                icon: LxIcons.debug,
                onTap: this.onDebugPressed,
              ),

            const SizedBox(height: Space.s600),

            // < Invite Friends >
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: Space.s500),
              child: LxOutlinedButton(
                // TODO(phlip9): we use a closure to see button w/o disabled
                // styling. remove extra closure when real functionality exists.
                onTap: () => this.onInvitePressed?.call(),
                label: const Text("Invite Friends"),
              ),
            ),
            const SizedBox(height: Space.s600),

            // app version
            Text("Lexe App · v1.2.345",
                textAlign: TextAlign.center,
                style: Fonts.fontUI.copyWith(
                  color: LxColors.grey600,
                  fontSize: Fonts.size200,
                )),
          ],
        ),
      ),
    );
  }
}

class DrawerListItem extends StatelessWidget {
  const DrawerListItem({super.key, this.title, this.icon, this.onTap});

  final String? title;
  final IconData? icon;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      contentPadding: const EdgeInsets.symmetric(horizontal: Space.s500),
      horizontalTitleGap: Space.s200,
      visualDensity: VisualDensity.standard,
      dense: false,
      leading: (this.icon != null)
          ? Icon(
              this.icon!,
              color: LxColors.foreground,
              size: Fonts.size700,
            )
          : null,
      title: (this.title != null)
          ? Text(this.title!,
              style: Fonts.fontUI.copyWith(
                fontSize: Fonts.size400,
                fontVariations: [Fonts.weightMedium],
              ))
          : null,
      onTap: this.onTap,
    );
  }
}

@freezed
class BalanceState with _$BalanceState {
  const factory BalanceState({
    required int? balanceSats,
    required String fiatName,
    required FiatRate? fiatRate,
  }) = _BalanceState;

  const BalanceState._();

  static BalanceState placeholder =
      const BalanceState(balanceSats: null, fiatName: "USD", fiatRate: null);

  double? fiatBalance() => (this.balanceSats != null && this.fiatRate != null)
      ? currency_format.satsToBtc(this.balanceSats!) * this.fiatRate!.rate
      : null;
}

class BalanceWidget extends StatelessWidget {
  const BalanceWidget(this.state, {super.key});

  final BalanceState state;

  @override
  Widget build(BuildContext context) {
    const satsBalanceSize = Fonts.size300;
    final satsBalanceOrPlaceholder = (this.state.balanceSats != null)
        ? Text(
            currency_format.formatSatsAmount(this.state.balanceSats!),
            style: Fonts.fontUI.copyWith(
              fontSize: satsBalanceSize,
              color: LxColors.grey700,
              fontVariations: [Fonts.weightMedium],
            ),
          )
        : const FilledPlaceholder(
            width: Space.s1000,
            height: satsBalanceSize,
            forText: true,
          );

    final fiatBalance = this.state.fiatBalance();
    final fiatBalanceOrPlaceholder = (fiatBalance != null)
        ? PrimaryBalanceText(
            fiatBalance: fiatBalance,
            fiatName: this.state.fiatRate!.fiat,
          )
        : const FilledPlaceholder(
            width: Space.s1100,
            height: Fonts.size800,
            forText: true,
          );

    return Column(
      children: [
        fiatBalanceOrPlaceholder,
        const SizedBox(height: Space.s400),
        satsBalanceOrPlaceholder,
      ],
    );
  }
}

class PrimaryBalanceText extends StatelessWidget {
  const PrimaryBalanceText({
    super.key,
    required this.fiatBalance,
    required this.fiatName,
  });

  final double fiatBalance;
  final String fiatName;

  @override
  Widget build(BuildContext context) {
    final (fiatBalanceWhole, fiatBalanceFract) =
        currency_format.formatFiatParts(this.fiatBalance, this.fiatName);

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          fiatBalanceWhole,
          style: Fonts.fontUI.copyWith(
            fontSize: Fonts.size800,
            fontVariations: [Fonts.weightMedium],
          ),
        ),
        if (fiatBalanceFract.isNotEmpty)
          Text(
            fiatBalanceFract,
            style: Fonts.fontUI.copyWith(
              fontSize: Fonts.size800,
              color: LxColors.fgTertiary,
              fontVariations: [Fonts.weightMedium],
            ),
          ),
      ],
    );
  }
}

class WalletActions extends StatelessWidget {
  const WalletActions({
    super.key,
    this.onScanPressed,
    this.onSendPressed,
    this.onReceivePressed,
  });

  final VoidCallback? onScanPressed;
  final VoidCallback? onSendPressed;
  final VoidCallback? onReceivePressed;

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        WalletActionButton(
          onPressed: this.onScanPressed,
          icon: LxIcons.scan,
          label: "Scan",
        ),
        const SizedBox(width: Space.s400),
        WalletActionButton(
          onPressed: this.onReceivePressed,
          icon: LxIcons.receive,
          label: "Receive",
        ),
        const SizedBox(width: Space.s400),
        WalletActionButton(
          onPressed: this.onSendPressed,
          icon: LxIcons.send,
          label: "Send",
        ),
      ],
    );
  }
}

class WalletActionButton extends StatelessWidget {
  const WalletActionButton({
    super.key,
    required this.onPressed,
    required this.icon,
    required this.label,
  });

  final VoidCallback? onPressed;
  final IconData icon;
  final String label;

  @override
  Widget build(BuildContext context) {
    final bool isDisabled = (this.onPressed == null);

    return Column(
      children: [
        FilledButton(
          onPressed: this.onPressed,
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: Space.s450),
            child: Icon(this.icon, size: Fonts.size700),
          ),
        ),
        const SizedBox(height: Space.s400),
        Text(
          label,
          style: Fonts.fontUI.copyWith(
            fontSize: Fonts.size300,
            color: (!isDisabled) ? LxColors.foreground : LxColors.grey725,
            fontVariations: [Fonts.weightSemiBold],
          ),
        ),
      ],
    );
  }
}

enum PaymentsListFilter {
  all,
  pending,
  pendingNotJunk,
  finalized,
  finalizedNotJunk,
  ;

  String asTitle() => switch (this) {
        all => "Payments",
        pending => "Pending",
        pendingNotJunk => "Pending",
        finalized => "Completed",
        finalizedNotJunk => "Completed",
      };
}

typedef PaymentTapCallback = void Function(int paymentVecIdx);

class SliverPaymentsList extends StatefulWidget {
  const SliverPaymentsList({
    super.key,
    required this.app,
    required this.filter,
    required this.onPaymentTap,
  });

  final AppHandle app;
  final PaymentsListFilter filter;
  final PaymentTapCallback onPaymentTap;

  @override
  State<SliverPaymentsList> createState() => _SliverPaymentsListState();
}

class _SliverPaymentsListState extends State<SliverPaymentsList> {
  // When this stream ticks, all the payments' createdAt label should update.
  // This stream ticks every 30 seconds. All the payment times should also
  // update at the same time, which is why they all share the same ticker
  // stream, hoisted up here to the parent list widget.
  final StateSubject<DateTime> paymentDateUpdates =
      StateSubject(DateTime.now());
  Timer? paymentDateUpdatesTimer;

  @override
  void dispose() {
    this.paymentDateUpdatesTimer?.cancel();
    this.paymentDateUpdates.close();

    super.dispose();
  }

  @override
  void initState() {
    super.initState();

    this.paymentDateUpdatesTimer =
        Timer.periodic(const Duration(seconds: 30), (timer) {
      this.paymentDateUpdates.addIfNotClosed(DateTime.now());
    });
  }

  @override
  Widget build(BuildContext context) {
    final int paymentKindCount = switch (this.widget.filter) {
      PaymentsListFilter.all => this.widget.app.getNumPayments(),
      PaymentsListFilter.pending => this.widget.app.getNumPendingPayments(),
      PaymentsListFilter.pendingNotJunk =>
        this.widget.app.getNumPendingNotJunkPayments(),
      PaymentsListFilter.finalized => this.widget.app.getNumFinalizedPayments(),
      PaymentsListFilter.finalizedNotJunk =>
        this.widget.app.getNumFinalizedNotJunkPayments(),
    };
    info("build SliverPaymentsList: filter: ${this.widget.filter}, "
        "paymentKindCount: $paymentKindCount");

    final numHeaders = switch (paymentKindCount) {
      > 0 => 1,
      _ => 0,
    };
    final childCount = paymentKindCount + numHeaders;

    return SliverFixedExtentList(
      itemExtent: Space.s800,
      delegate: SliverChildBuilderDelegate(
        childCount: childCount,
        (context, paymentPlusHeaderIdx) {
          if (paymentPlusHeaderIdx < numHeaders) {
            return Align(
              alignment: Alignment.bottomLeft,
              child: Padding(
                padding: const EdgeInsets.symmetric(
                    horizontal: Space.s400, vertical: Space.s200),
                child: Text(
                  this.widget.filter.asTitle(),
                  style: Fonts.fontUI.copyWith(
                    fontSize: Fonts.size200,
                    color: LxColors.fgTertiary,
                    fontVariations: [Fonts.weightMedium],
                  ),
                ),
              ),
            );
          }

          final scrollIdx = paymentPlusHeaderIdx - numHeaders;

          final ShortPaymentAndIndex? result = switch (this.widget.filter) {
            PaymentsListFilter.all =>
              this.widget.app.getShortPaymentByScrollIdx(scrollIdx: scrollIdx),
            PaymentsListFilter.pending => this
                .widget
                .app
                .getPendingShortPaymentByScrollIdx(scrollIdx: scrollIdx),
            PaymentsListFilter.pendingNotJunk => this
                .widget
                .app
                .getPendingNotJunkShortPaymentByScrollIdx(scrollIdx: scrollIdx),
            PaymentsListFilter.finalized => this
                .widget
                .app
                .getFinalizedShortPaymentByScrollIdx(scrollIdx: scrollIdx),
            PaymentsListFilter.finalizedNotJunk => this
                .widget
                .app
                .getFinalizedNotJunkShortPaymentByScrollIdx(
                    scrollIdx: scrollIdx),
          };
          if (result == null) return null;

          return PaymentsListEntry(
            vecIdx: result.vecIdx,
            payment: result.payment,
            paymentDateUpdates: this.paymentDateUpdates,
            onTap: () => this.widget.onPaymentTap(result.vecIdx),
          );
        },
        // findChildIndexCallback: (Key childKey) => this.app.getPaymentScrollIdxByPaymentId(childKey),
      ),
    );
  }
}

String formatFiatValue({
  required FiatRate? rate,
  required int? amountSats,
  required PaymentDirection direction,
}) {
  if (rate == null || amountSats == null) {
    return "";
  }

  final fiatValue = currency_format.satsToBtc(amountSats) * rate.rate;
  final sign = currency_format.directionToSign(direction);

  final NumberFormat currencyFormatter =
      NumberFormat.simpleCurrency(name: rate.fiat);
  return "$sign${currencyFormatter.format(fiatValue)}";
}

class PaymentsListEntry extends StatelessWidget {
  PaymentsListEntry({
    required int vecIdx,
    required this.payment,
    required this.paymentDateUpdates,
    required this.onTap,
  }) : super(key: ValueKey<int>(vecIdx));

  final VoidCallback onTap;
  final StateStream<DateTime> paymentDateUpdates;
  final ShortPayment payment;

  @override
  Widget build(BuildContext context) {
    final status = this.payment.status;
    final direction = this.payment.direction;
    final kind = this.payment.kind;
    final amountSats = this.payment.amountSat;
    final note = this.payment.note;

    final leadingIcon = PaymentListIcon(kind: kind);

    // TODO(phlip9): figure out a heuristic to get the counterparty name.
    final String primaryStr;
    if (status == PaymentStatus.Pending) {
      if (direction == PaymentDirection.Inbound) {
        primaryStr = "Receiving payment";
      } else {
        primaryStr = "Sending payment";
      }
    } else {
      if (direction == PaymentDirection.Inbound) {
        primaryStr = "You received";
      } else {
        primaryStr = "You sent";
      }
    }

    // ex: "Receiving payment" (pending, inbound)
    // ex: "Sending payment" (pending, outbound)
    // ex: "You received" (finalized, inbound)
    // ex: "You sent" (finalized, outbound)
    final primaryText = Text(
      primaryStr,
      maxLines: 1,
      style: Fonts.fontUI.copyWith(
        fontSize: Fonts.size300,
        color: LxColors.fgSecondary,
        fontVariations: [Fonts.weightMedium],
      ),
    );

    // TODO(phlip9): display as BTC rather than sats depending on user
    //               preferences.
    // the weird unicode thing that isn't rendering is the BTC B currency symbol
    // "+₿0.00001230",

    final Color primaryValueColor;
    if (direction == PaymentDirection.Inbound &&
        status != PaymentStatus.Failed) {
      primaryValueColor = LxColors.moneyGoUp;
    } else {
      primaryValueColor = LxColors.fgSecondary;
    }

    final String amountSatsStr = (amountSats != null)
        ? currency_format.formatSatsAmount(amountSats,
            direction: direction, satsSuffix: true)
        : "";

    // ex: "" (certain niche cases w/ failed or pending LN invoice payments)
    // ex: "+45,000 sats"
    // ex: "-128 sats"
    final primaryValueText = Text(
      amountSatsStr,
      maxLines: 1,
      textAlign: TextAlign.end,
      style: Fonts.fontUI.copyWith(
        fontSize: Fonts.size200,
        color: primaryValueColor,
      ),
    );

    // ex: "Failed" (payment failed, no note)
    // ex: "Brunch with friends" (note only)
    // ex: "Failed · Funds from Boincase" (failed + note)
    final secondaryText = RichText(
      text: TextSpan(
        text: null,
        children: <TextSpan>[
          // prefix with "Failed" to indicate problem w/ payment.
          if (status == PaymentStatus.Failed)
            const TextSpan(
              text: "Failed",
              style: TextStyle(
                color: LxColors.errorText,
                // fontVariations: [Fonts.weightMedium],
              ),
            ),
          // separator should only show if both sides are present
          if (status == PaymentStatus.Failed && note != null)
            const TextSpan(text: " · "),
          if (note != null) TextSpan(text: note)
        ],
        style: Fonts.fontUI.copyWith(
          fontSize: Fonts.size200,
          color: LxColors.fgTertiary,
        ),
      ),
      maxLines: 1,
      overflow: TextOverflow.ellipsis,
    );

    // Wrap the "createdAt" text so that it updates every ~30 sec, not just
    // when we refresh.
    final createdAt = DateTime.fromMillisecondsSinceEpoch(payment.createdAt);
    final secondaryDateText = StateStreamBuilder(
        stream: this.paymentDateUpdates,
        builder: (_, now) {
          final createdAtStr =
              date_format.formatDateCompact(then: createdAt, now: now);

          // ex: "just now" (less than a min old)
          // ex: "10min"
          // ex: "Jun 16"
          // ex: "14h"
          return Text(
            createdAtStr ?? "",
            maxLines: 1,
            textAlign: TextAlign.end,
            style: Fonts.fontUI.copyWith(
              fontSize: Fonts.size200,
              color: LxColors.fgTertiary,
            ),
          );
        });

    return ListTile(
      onTap: this.onTap,

      // list tile styling

      contentPadding: const EdgeInsets.symmetric(
        horizontal: Space.s400,
        vertical: Space.s0,
      ),
      horizontalTitleGap: Space.s200,
      visualDensity: VisualDensity.standard,
      dense: true,

      // actual content

      leading: leadingIcon,

      // NOTE: we use a Row() in `title` and `subtitle` instead of `trailing` so
      // that the text baselines align properly.

      title: Row(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.baseline,
        textBaseline: TextBaseline.alphabetic,
        children: [
          Expanded(
            child: primaryText,
          ),
          Padding(
            padding: const EdgeInsets.only(left: Space.s200),
            child: primaryValueText,
          )
        ],
      ),

      subtitle: Row(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.baseline,
        textBaseline: TextBaseline.alphabetic,
        children: [
          Expanded(
            child: secondaryText,
          ),
          Padding(
            padding: const EdgeInsets.only(left: Space.s200),
            child: secondaryDateText,
          )
        ],
      ),
    );
  }
}

class PaymentListIcon extends StatelessWidget {
  const PaymentListIcon({
    super.key,
    required this.kind,
  });

  final PaymentKind kind;

  @override
  Widget build(BuildContext context) {
    final bool isLightning = switch (this.kind) {
      PaymentKind.Invoice || PaymentKind.Spontaneous => true,
      PaymentKind.Onchain => false,
    };

    const size = Space.s500;
    const color = LxColors.fgSecondary;

    return DecoratedBox(
      decoration: const BoxDecoration(
        color: LxColors.grey850,
        borderRadius: BorderRadius.all(Radius.circular(20.0)),
      ),
      child: SizedBox.square(
        // pixel perfect alignment
        dimension: 39.0,
        child: (isLightning)
            ? const Icon(
                LxIcons.lightning,
                size: size,
                color: color,
                fill: 1.0,
                weight: LxIcons.weightLight,
              )
            : const Icon(
                LxIcons.bitcoin,
                size: size,
                color: color,
              ),
      ),
    );
  }
}
