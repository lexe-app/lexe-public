import 'package:app_rs_dart/ffi/api.dart' show Balance, FiatRate;
import 'package:app_rs_dart/ffi/types.dart' show PaymentKind;
import 'package:freezed_annotation/freezed_annotation.dart' show freezed;
import 'package:lexeapp/currency_format.dart' as currency_format;
import 'package:lexeapp/int_ext.dart';

// Include code generated by @freezed
part 'types.freezed.dart';

/// An amount in a particular currency.
final class FiatAmount {
  const FiatAmount(this.fiat, this.amount);

  FiatAmount.fromBtc(FiatRate rate, double amountBtc)
    : fiat = rate.fiat,
      amount = amountBtc * rate.rate;

  factory FiatAmount.fromSats(FiatRate rate, int amountSats) =>
      FiatAmount.fromBtc(rate, currency_format.satsToBtc(amountSats));

  static FiatAmount? maybeFromSats(FiatRate? rate, int? amountSats) =>
      (rate != null && amountSats != null)
      ? FiatAmount.fromSats(rate, amountSats)
      : null;

  final String fiat;
  final double amount;

  @override
  int get hashCode => this.fiat.hashCode ^ this.amount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FiatAmount &&
          this.runtimeType == other.runtimeType &&
          this.fiat == other.fiat &&
          this.amount == other.amount;
}

/// A Lexe user has multiple balances. Currently we support on-chain Bitcoin and
/// outbound Lightning channel balances.
enum BalanceKind {
  onchain,
  lightning;

  static BalanceKind fromPaymentKind(final PaymentKind kind) => switch (kind) {
    PaymentKind.onchain => BalanceKind.onchain,
    PaymentKind.invoice ||
    PaymentKind.spontaneous ||
    PaymentKind.offer => BalanceKind.lightning,
  };
}

/// The current wallet balances, combined with the current preferred [FiatRate].
@freezed
class BalanceState with _$BalanceState {
  const factory BalanceState({
    required Balance? balanceSats,
    required FiatRate? fiatRate,
  }) = _BalanceState;

  const BalanceState._();

  static BalanceState placeholder = const BalanceState(
    balanceSats: null,
    fiatRate: null,
  );

  int? totalSats() => this.balanceSats?.totalSats;
  int? onchainSats() => this.balanceSats?.onchainSats;
  int? lightningSats() => this.balanceSats?.lightningSats;
  int? lightningMaxSendableSats() => this.balanceSats?.lightningMaxSendableSats;
  int? lightningChannelReserveSats() {
    // Technically this calculation includes not just the channel punishment
    // reserve but also in-flight HTLC hold amounts. For user nodes this
    // distinction is negligible.
    final b = this.balanceSats;
    return (b != null)
        ? b.lightningUsableSats.saturatingSub(b.lightningMaxSendableSats)
        : null;
  }

  int? byKindSats(BalanceKind kind) => switch (kind) {
    BalanceKind.onchain => this.onchainSats(),
    BalanceKind.lightning => this.lightningSats(),
  };

  FiatAmount? totalFiat() => this._convertFiat(this.totalSats());
  FiatAmount? onchainFiat() => this._convertFiat(this.onchainSats());
  FiatAmount? lightningFiat() => this._convertFiat(this.lightningSats());
  FiatAmount? lightningMaxSendableFiat() =>
      this._convertFiat(this.lightningMaxSendableSats());

  FiatAmount? byKindFiat(BalanceKind kind) => switch (kind) {
    BalanceKind.onchain => this.onchainFiat(),
    BalanceKind.lightning => this.lightningFiat(),
  };

  FiatAmount? _convertFiat(final int? satsBalance) =>
      (satsBalance != null && this.fiatRate != null)
      ? FiatAmount(
          this.fiatRate!.fiat,
          currency_format.satsToBtc(satsBalance) * this.fiatRate!.rate,
        )
      : null;
}
