// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

//
// From: `dart_preamble` in `app-rs-codegen/src/lib.rs`
// ignore_for_file: invalid_internal_annotation, always_use_package_imports, directives_ordering, prefer_const_constructors, sort_unnamed_constructors_first
//

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'api.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `new`

/// Validate whether `address_str` is a properly formatted bitcoin address. Also
/// checks that it's valid for the configured bitcoin network.
///
/// The return type is a bit funky: `Option<String>`. `None` means
/// `address_str` is valid, while `Some(msg)` means it is not (with given
/// error message). We return in this format to better match the flutter
/// `FormField` validator API.
String? formValidateBitcoinAddress(
        {required String addressStr, required Network currentNetwork}) =>
    AppRs.instance.api.crateFfiFfiFormValidateBitcoinAddress(
        addressStr: addressStr, currentNetwork: currentNetwork);

/// Validate whether `password` has an appropriate length.
///
/// The return type is a bit funky: `Option<String>`. `None` means
/// `address_str` is valid, while `Some(msg)` means it is not (with given
/// error message). We return in this format to better match the flutter
/// `FormField` validator API.
String? formValidatePassword({required String password}) =>
    AppRs.instance.api.crateFfiFfiFormValidatePassword(password: password);

/// Resolve a (possible) [`PaymentUri`] string that we just
/// scanned/pasted into the best [`PaymentMethod`] for us to pay.
///
/// [`PaymentUri`]: payment_uri::PaymentUri
Future<PaymentMethod> paymentUriResolveBest(
        {required Network network, required String uriStr}) =>
    AppRs.instance.api
        .crateFfiFfiPaymentUriResolveBest(network: network, uriStr: uriStr);

/// Init the Rust [`tracing`] logger. Also sets the current `RUST_LOG_TX`
/// instance, which ships Rust logs over to the dart side for printing.
///
/// Since `println!`/stdout gets swallowed on mobile, we ship log messages over
/// to dart for printing. Otherwise we can't see logs while developing.
///
/// When dart calls this function, it generates a `log_tx` and `log_rx`, then
/// sends the `log_tx` to Rust while holding on to the `log_rx`. When Rust gets
/// a new [`tracing`] log event, it enqueues the formatted log onto the
/// `log_tx`.
///
/// Unlike our other Rust loggers, this init will _not_ panic if a
/// logger instance is already set. Instead it will just update the
/// `RUST_LOG_TX`. This funky setup allows us to seamlessly support flutter's
/// hot restart, which would otherwise try to re-init the logger (and cause a
/// panic) but we still need to register a new log tx.
///
/// `rust_log`: since env vars don't work well on mobile, we need to ship the
/// equivalent of `$RUST_LOG` configured at build-time through here.
Stream<String> initRustLogStream({required String rustLog}) =>
    AppRs.instance.api.crateFfiFfiInitRustLogStream(rustLog: rustLog);

/// Delete the local persisted `SecretStore` and `RootSeed`.
///
/// WARNING: you will need a backup recovery to use the account afterwards.
void debugDeleteSecretStore({required Config config}) =>
    AppRs.instance.api.crateFfiFfiDebugDeleteSecretStore(config: config);

/// Delete the local latest_release file.
void debugDeleteLatestProvisioned({required Config config}) =>
    AppRs.instance.api.crateFfiFfiDebugDeleteLatestProvisioned(config: config);

/// Unconditionally panic (for testing).
Future<void> debugUnconditionalPanic() =>
    AppRs.instance.api.crateFfiFfiDebugUnconditionalPanic();

/// Unconditionally return Err (for testing).
Future<void> debugUnconditionalError() =>
    AppRs.instance.api.crateFfiFfiDebugUnconditionalError();

// Rust type: RustOpaqueNom<App>
abstract class App implements RustOpaqueInterface {}

/// The `AppHandle` is a Dart representation of an [`App`] instance.
class AppHandle {
  final App inner;

  const AppHandle({
    required this.inner,
  });

  Future<CreateInvoiceResponse> createInvoice(
          {required CreateInvoiceRequest req}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandleCreateInvoice(that: this, req: req);

  /// Delete both the local payment state and the on-disk payment db.
  Future<void> deletePaymentDb() =>
      AppRs.instance.api.crateFfiFfiAppHandleDeletePaymentDb(
        that: this,
      );

  Future<FiatRates> fiatRates() =>
      AppRs.instance.api.crateFfiFfiAppHandleFiatRates(
        that: this,
      );

  Future<String> getAddress() =>
      AppRs.instance.api.crateFfiFfiAppHandleGetAddress(
        that: this,
      );

  ShortPaymentAndIndex? getFinalizedNotJunkShortPaymentByScrollIdx(
          {required int scrollIdx}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandleGetFinalizedNotJunkShortPaymentByScrollIdx(
              that: this, scrollIdx: scrollIdx);

  ShortPaymentAndIndex? getFinalizedShortPaymentByScrollIdx(
          {required int scrollIdx}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandleGetFinalizedShortPaymentByScrollIdx(
              that: this, scrollIdx: scrollIdx);

  int getNumFinalizedNotJunkPayments() =>
      AppRs.instance.api.crateFfiFfiAppHandleGetNumFinalizedNotJunkPayments(
        that: this,
      );

  int getNumFinalizedPayments() =>
      AppRs.instance.api.crateFfiFfiAppHandleGetNumFinalizedPayments(
        that: this,
      );

  int getNumPayments() => AppRs.instance.api.crateFfiFfiAppHandleGetNumPayments(
        that: this,
      );

  int getNumPendingNotJunkPayments() =>
      AppRs.instance.api.crateFfiFfiAppHandleGetNumPendingNotJunkPayments(
        that: this,
      );

  int getNumPendingPayments() =>
      AppRs.instance.api.crateFfiFfiAppHandleGetNumPendingPayments(
        that: this,
      );

  Payment? getPaymentByVecIdx({required int vecIdx}) => AppRs.instance.api
      .crateFfiFfiAppHandleGetPaymentByVecIdx(that: this, vecIdx: vecIdx);

  ShortPaymentAndIndex? getPendingNotJunkShortPaymentByScrollIdx(
          {required int scrollIdx}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandleGetPendingNotJunkShortPaymentByScrollIdx(
              that: this, scrollIdx: scrollIdx);

  ShortPaymentAndIndex? getPendingShortPaymentByScrollIdx(
          {required int scrollIdx}) =>
      AppRs.instance.api.crateFfiFfiAppHandleGetPendingShortPaymentByScrollIdx(
          that: this, scrollIdx: scrollIdx);

  ShortPaymentAndIndex? getShortPaymentByScrollIdx({required int scrollIdx}) =>
      AppRs.instance.api.crateFfiFfiAppHandleGetShortPaymentByScrollIdx(
          that: this, scrollIdx: scrollIdx);

  Future<int?> getVecIdxByPaymentIndex({required PaymentIndex paymentIndex}) =>
      AppRs.instance.api.crateFfiFfiAppHandleGetVecIdxByPaymentIndex(
          that: this, paymentIndex: paymentIndex);

  static Future<AppHandle?> load({required Config config}) =>
      AppRs.instance.api.crateFfiFfiAppHandleLoad(config: config);

  Future<NodeInfo> nodeInfo() =>
      AppRs.instance.api.crateFfiFfiAppHandleNodeInfo(
        that: this,
      );

  Future<PayInvoiceResponse> payInvoice({required PayInvoiceRequest req}) =>
      AppRs.instance.api.crateFfiFfiAppHandlePayInvoice(that: this, req: req);

  Future<PayOnchainResponse> payOnchain({required PayOnchainRequest req}) =>
      AppRs.instance.api.crateFfiFfiAppHandlePayOnchain(that: this, req: req);

  Future<PreflightPayInvoiceResponse> preflightPayInvoice(
          {required PreflightPayInvoiceRequest req}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandlePreflightPayInvoice(that: this, req: req);

  Future<PreflightPayOnchainResponse> preflightPayOnchain(
          {required PreflightPayOnchainRequest req}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandlePreflightPayOnchain(that: this, req: req);

  static Future<AppHandle> restore(
          {required Config config, required String seedPhrase}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandleRestore(config: config, seedPhrase: seedPhrase);

  static Future<AppHandle> signup(
          {required Config config,
          required String googleAuthCode,
          required String password}) =>
      AppRs.instance.api.crateFfiFfiAppHandleSignup(
          config: config, googleAuthCode: googleAuthCode, password: password);

  /// Sync the local payment DB to the remote node.
  ///
  /// Returns `true` if any payment changed, so we know whether to reload the
  /// payment list UI.
  Future<bool> syncPayments() =>
      AppRs.instance.api.crateFfiFfiAppHandleSyncPayments(
        that: this,
      );

  Future<void> updatePaymentNote({required UpdatePaymentNote req}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandleUpdatePaymentNote(that: this, req: req);

  @override
  int get hashCode => inner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AppHandle &&
          runtimeType == other.runtimeType &&
          inner == other.inner;
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array32(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array32.init() : this(Uint8List(arraySize));
}
