// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

//
// From: `dart_preamble` in `app-rs-codegen/src/lib.rs`
// ignore_for_file: invalid_internal_annotation, always_use_package_imports, directives_ordering, prefer_const_constructors, sort_unnamed_constructors_first
//

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

/// Validate whether `address_str` is a properly formatted bitcoin address. Also
/// checks that it's valid for the configured bitcoin network.
///
/// The return type is a bit funky: `Option<String>`. `None` means
/// `address_str` is valid, while `Some(msg)` means it is not (with given
/// error message). We return in this format to better match the flutter
/// `FormField` validator API.
String? formValidateBitcoinAddress(
        {required String addressStr, required Network currentNetwork}) =>
    AppRs.instance.api.crateFfiFfiFormValidateBitcoinAddress(
        addressStr: addressStr, currentNetwork: currentNetwork);

/// Validate whether `password` has an appropriate length.
///
/// The return type is a bit funky: `Option<String>`. `None` means
/// `address_str` is valid, while `Some(msg)` means it is not (with given
/// error message). We return in this format to better match the flutter
/// `FormField` validator API.
String? formValidatePassword({required String password}) =>
    AppRs.instance.api.crateFfiFfiFormValidatePassword(password: password);

/// Resolve a (possible) [`PaymentUri`] string that we just
/// scanned/pasted into the best [`PaymentMethod`] for us to pay.
///
/// [`PaymentUri`]: payment_uri::PaymentUri
Future<PaymentMethod> paymentUriResolveBest(
        {required Network network, required String uriStr}) =>
    AppRs.instance.api
        .crateFfiFfiPaymentUriResolveBest(network: network, uriStr: uriStr);

/// Init the Rust [`tracing`] logger. Also sets the current `RUST_LOG_TX`
/// instance, which ships Rust logs over to the dart side for printing.
///
/// Since `println!`/stdout gets swallowed on mobile, we ship log messages over
/// to dart for printing. Otherwise we can't see logs while developing.
///
/// When dart calls this function, it generates a `log_tx` and `log_rx`, then
/// sends the `log_tx` to Rust while holding on to the `log_rx`. When Rust gets
/// a new [`tracing`] log event, it enqueues the formatted log onto the
/// `log_tx`.
///
/// Unlike our other Rust loggers, this init will _not_ panic if a
/// logger instance is already set. Instead it will just update the
/// `RUST_LOG_TX`. This funky setup allows us to seamlessly support flutter's
/// hot restart, which would otherwise try to re-init the logger (and cause a
/// panic) but we still need to register a new log tx.
///
/// `rust_log`: since env vars don't work well on mobile, we need to ship the
/// equivalent of `$RUST_LOG` configured at build-time through here.
Stream<String> initRustLogStream({required String rustLog}) =>
    AppRs.instance.api.crateFfiFfiInitRustLogStream(rustLog: rustLog);

/// Delete the local persisted `SecretStore` and `RootSeed`.
///
/// WARNING: you will need a backup recovery to use the account afterwards.
void debugDeleteSecretStore({required Config config}) =>
    AppRs.instance.api.crateFfiFfiDebugDeleteSecretStore(config: config);

/// Delete the local latest_release file.
void debugDeleteLatestProvisioned({required Config config}) =>
    AppRs.instance.api.crateFfiFfiDebugDeleteLatestProvisioned(config: config);

/// Unconditionally panic (for testing).
Future<void> debugUnconditionalPanic() =>
    AppRs.instance.api.crateFfiFfiDebugUnconditionalPanic();

/// Unconditionally return Err (for testing).
Future<void> debugUnconditionalError() =>
    AppRs.instance.api.crateFfiFfiDebugUnconditionalError();
