// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

//
// From: `dart_preamble` in `app-rs-codegen/src/lib.rs`
// ignore_for_file: invalid_internal_annotation, always_use_package_imports, directives_ordering, prefer_const_constructors, sort_unnamed_constructors_first
//

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'types.dart';
part 'ffi.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `from_cid_and_response`, `from_id_and_response`, `new`, `validate_note`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`, `from`, `from`, `from`, `from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`

/// Validate whether `address_str` is a properly formatted bitcoin address. Also
/// checks that it's valid for the configured bitcoin network.
///
/// The return type is a bit funky: `Option<String>`. `None` means
/// `address_str` is valid, while `Some(msg)` means it is not (with given
/// error message). We return in this format to better match the flutter
/// `FormField` validator API.
String? formValidateBitcoinAddress(
        {required String addressStr, required Network currentNetwork}) =>
    AppRs.instance.api.crateFfiFfiFormValidateBitcoinAddress(
        addressStr: addressStr, currentNetwork: currentNetwork);

/// Validate whether `password` has an appropriate length.
///
/// The return type is a bit funky: `Option<String>`. `None` means
/// `address_str` is valid, while `Some(msg)` means it is not (with given
/// error message). We return in this format to better match the flutter
/// `FormField` validator API.
String? formValidatePassword({required String password}) =>
    AppRs.instance.api.crateFfiFfiFormValidatePassword(password: password);

/// Resolve a (possible) [`PaymentUri`] string that we just
/// scanned/pasted into the best [`PaymentMethod`] for us to pay.
///
/// [`PaymentUri`]: payment_uri::PaymentUri
Future<PaymentMethod> paymentUriResolveBest(
        {required Network network, required String uriStr}) =>
    AppRs.instance.api
        .crateFfiFfiPaymentUriResolveBest(network: network, uriStr: uriStr);

/// Init the Rust [`tracing`] logger. Also sets the current `RUST_LOG_TX`
/// instance, which ships Rust logs over to the dart side for printing.
///
/// Since `println!`/stdout gets swallowed on mobile, we ship log messages over
/// to dart for printing. Otherwise we can't see logs while developing.
///
/// When dart calls this function, it generates a `log_tx` and `log_rx`, then
/// sends the `log_tx` to Rust while holding on to the `log_rx`. When Rust gets
/// a new [`tracing`] log event, it enqueues the formatted log onto the
/// `log_tx`.
///
/// Unlike our other Rust loggers, this init will _not_ panic if a
/// logger instance is already set. Instead it will just update the
/// `RUST_LOG_TX`. This funky setup allows us to seamlessly support flutter's
/// hot restart, which would otherwise try to re-init the logger (and cause a
/// panic) but we still need to register a new log tx.
///
/// `rust_log`: since env vars don't work well on mobile, we need to ship the
/// equivalent of `$RUST_LOG` configured at build-time through here.
Stream<String> initRustLogStream({required String rustLog}) =>
    AppRs.instance.api.crateFfiFfiInitRustLogStream(rustLog: rustLog);

/// Delete the local persisted `SecretStore` and `RootSeed`.
///
/// WARNING: you will need a backup recovery to use the account afterwards.
void debugDeleteSecretStore({required Config config}) =>
    AppRs.instance.api.crateFfiFfiDebugDeleteSecretStore(config: config);

/// Delete the local latest_release file.
void debugDeleteLatestProvisioned({required Config config}) =>
    AppRs.instance.api.crateFfiFfiDebugDeleteLatestProvisioned(config: config);

/// Unconditionally panic (for testing).
Future<void> debugUnconditionalPanic() =>
    AppRs.instance.api.crateFfiFfiDebugUnconditionalPanic();

/// Unconditionally return Err (for testing).
Future<void> debugUnconditionalError() =>
    AppRs.instance.api.crateFfiFfiDebugUnconditionalError();

// Rust type: RustOpaqueNom<App>
abstract class App implements RustOpaqueInterface {}

/// The `AppHandle` is a Dart representation of an [`App`] instance.
class AppHandle {
  final App inner;

  const AppHandle({
    required this.inner,
  });

  Future<CreateInvoiceResponse> createInvoice(
          {required CreateInvoiceRequest req}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandleCreateInvoice(that: this, req: req);

  /// Delete both the local payment state and the on-disk payment db.
  Future<void> deletePaymentDb() =>
      AppRs.instance.api.crateFfiFfiAppHandleDeletePaymentDb(
        that: this,
      );

  Future<FiatRates> fiatRates() =>
      AppRs.instance.api.crateFfiFfiAppHandleFiatRates(
        that: this,
      );

  Future<String> getAddress() =>
      AppRs.instance.api.crateFfiFfiAppHandleGetAddress(
        that: this,
      );

  ShortPaymentAndIndex? getFinalizedNotJunkShortPaymentByScrollIdx(
          {required int scrollIdx}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandleGetFinalizedNotJunkShortPaymentByScrollIdx(
              that: this, scrollIdx: scrollIdx);

  ShortPaymentAndIndex? getFinalizedShortPaymentByScrollIdx(
          {required int scrollIdx}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandleGetFinalizedShortPaymentByScrollIdx(
              that: this, scrollIdx: scrollIdx);

  int getNumFinalizedNotJunkPayments() =>
      AppRs.instance.api.crateFfiFfiAppHandleGetNumFinalizedNotJunkPayments(
        that: this,
      );

  int getNumFinalizedPayments() =>
      AppRs.instance.api.crateFfiFfiAppHandleGetNumFinalizedPayments(
        that: this,
      );

  int getNumPayments() => AppRs.instance.api.crateFfiFfiAppHandleGetNumPayments(
        that: this,
      );

  int getNumPendingNotJunkPayments() =>
      AppRs.instance.api.crateFfiFfiAppHandleGetNumPendingNotJunkPayments(
        that: this,
      );

  int getNumPendingPayments() =>
      AppRs.instance.api.crateFfiFfiAppHandleGetNumPendingPayments(
        that: this,
      );

  Payment? getPaymentByVecIdx({required int vecIdx}) => AppRs.instance.api
      .crateFfiFfiAppHandleGetPaymentByVecIdx(that: this, vecIdx: vecIdx);

  ShortPaymentAndIndex? getPendingNotJunkShortPaymentByScrollIdx(
          {required int scrollIdx}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandleGetPendingNotJunkShortPaymentByScrollIdx(
              that: this, scrollIdx: scrollIdx);

  ShortPaymentAndIndex? getPendingShortPaymentByScrollIdx(
          {required int scrollIdx}) =>
      AppRs.instance.api.crateFfiFfiAppHandleGetPendingShortPaymentByScrollIdx(
          that: this, scrollIdx: scrollIdx);

  ShortPaymentAndIndex? getShortPaymentByScrollIdx({required int scrollIdx}) =>
      AppRs.instance.api.crateFfiFfiAppHandleGetShortPaymentByScrollIdx(
          that: this, scrollIdx: scrollIdx);

  Future<int?> getVecIdxByPaymentIndex({required PaymentIndex paymentIndex}) =>
      AppRs.instance.api.crateFfiFfiAppHandleGetVecIdxByPaymentIndex(
          that: this, paymentIndex: paymentIndex);

  static Future<AppHandle?> load({required Config config}) =>
      AppRs.instance.api.crateFfiFfiAppHandleLoad(config: config);

  Future<NodeInfo> nodeInfo() =>
      AppRs.instance.api.crateFfiFfiAppHandleNodeInfo(
        that: this,
      );

  Future<PayInvoiceResponse> payInvoice({required PayInvoiceRequest req}) =>
      AppRs.instance.api.crateFfiFfiAppHandlePayInvoice(that: this, req: req);

  Future<PayOnchainResponse> payOnchain({required PayOnchainRequest req}) =>
      AppRs.instance.api.crateFfiFfiAppHandlePayOnchain(that: this, req: req);

  Future<PreflightPayInvoiceResponse> preflightPayInvoice(
          {required PreflightPayInvoiceRequest req}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandlePreflightPayInvoice(that: this, req: req);

  Future<PreflightPayOnchainResponse> preflightPayOnchain(
          {required PreflightPayOnchainRequest req}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandlePreflightPayOnchain(that: this, req: req);

  static Future<AppHandle> restore(
          {required Config config, required String seedPhrase}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandleRestore(config: config, seedPhrase: seedPhrase);

  static Future<AppHandle> signup(
          {required Config config,
          required String googleAuthCode,
          required String password}) =>
      AppRs.instance.api.crateFfiFfiAppHandleSignup(
          config: config, googleAuthCode: googleAuthCode, password: password);

  /// Sync the local payment DB to the remote node.
  ///
  /// Returns `true` if any payment changed, so we know whether to reload the
  /// payment list UI.
  Future<bool> syncPayments() =>
      AppRs.instance.api.crateFfiFfiAppHandleSyncPayments(
        that: this,
      );

  Future<void> updatePaymentNote({required UpdatePaymentNote req}) =>
      AppRs.instance.api
          .crateFfiFfiAppHandleUpdatePaymentNote(that: this, req: req);

  @override
  int get hashCode => inner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AppHandle &&
          runtimeType == other.runtimeType &&
          inner == other.inner;
}

@freezed
class Balance with _$Balance {
  const factory Balance({
    required int totalSats,
    required int lightningSats,
    required int onchainSats,
  }) = _Balance;
}

/// See [`common::api::command::CreateInvoiceRequest`].
@freezed
class CreateInvoiceRequest with _$CreateInvoiceRequest {
  const factory CreateInvoiceRequest({
    required int expirySecs,
    int? amountSats,
    String? description,
  }) = _CreateInvoiceRequest;
}

/// See [`common::api::command::CreateInvoiceResponse`].
@freezed
class CreateInvoiceResponse with _$CreateInvoiceResponse {
  const factory CreateInvoiceResponse({
    required Invoice invoice,
  }) = _CreateInvoiceResponse;
}

/// See [`common::api::command::FeeEstimate`].
@freezed
class FeeEstimate with _$FeeEstimate {
  const factory FeeEstimate({
    required int amountSats,
  }) = _FeeEstimate;
}

@freezed
class FiatRate with _$FiatRate {
  const factory FiatRate({
    required String fiat,
    required double rate,
  }) = _FiatRate;
}

@freezed
class FiatRates with _$FiatRates {
  const factory FiatRates({
    required int timestampMs,
    required List<FiatRate> rates,
  }) = _FiatRates;
}

@freezed
class NodeInfo with _$NodeInfo {
  const factory NodeInfo({
    required String nodePk,
    required String version,
    required String measurement,
    required Balance balance,
  }) = _NodeInfo;
}

/// Mirrors the [`common::api::command::PayInvoiceRequest`] type.
@freezed
class PayInvoiceRequest with _$PayInvoiceRequest {
  const factory PayInvoiceRequest({
    required String invoice,
    int? fallbackAmountSats,
    String? note,
  }) = _PayInvoiceRequest;
}

/// Mirrors [`common::api::command::PayInvoiceResponse`] the type, but enriches
/// the response so we get the full `PaymentIndex`.
@freezed
class PayInvoiceResponse with _$PayInvoiceResponse {
  const factory PayInvoiceResponse({
    required PaymentIndex index,
  }) = _PayInvoiceResponse;
}

/// See [`common::api::command::PayOnchainRequest`].
@freezed
class PayOnchainRequest with _$PayOnchainRequest {
  const factory PayOnchainRequest({
    required ClientPaymentId cid,
    required String address,
    required int amountSats,
    required ConfirmationPriority priority,
    String? note,
  }) = _PayOnchainRequest;
}

/// See [`common::api::command::PayOnchainResponse`].
@freezed
class PayOnchainResponse with _$PayOnchainResponse {
  const factory PayOnchainResponse({
    required PaymentIndex index,
    required String txid,
  }) = _PayOnchainResponse;
}

/// See [`common::api::command::PreflightPayInvoiceRequest`].
@freezed
class PreflightPayInvoiceRequest with _$PreflightPayInvoiceRequest {
  const factory PreflightPayInvoiceRequest({
    required String invoice,
    int? fallbackAmountSats,
  }) = _PreflightPayInvoiceRequest;
}

/// See [`common::api::command::PreflightPayInvoiceResponse`].
@freezed
class PreflightPayInvoiceResponse with _$PreflightPayInvoiceResponse {
  const factory PreflightPayInvoiceResponse({
    required int amountSats,
    required int feesSats,
  }) = _PreflightPayInvoiceResponse;
}

/// See [`common::api::command::PreflightPayOnchainRequest`].
@freezed
class PreflightPayOnchainRequest with _$PreflightPayOnchainRequest {
  const factory PreflightPayOnchainRequest({
    required String address,
    required int amountSats,
  }) = _PreflightPayOnchainRequest;
}

/// See [`common::api::command::PreflightPayOnchainResponse`].
@freezed
class PreflightPayOnchainResponse with _$PreflightPayOnchainResponse {
  const factory PreflightPayOnchainResponse({
    FeeEstimate? high,
    required FeeEstimate normal,
    required FeeEstimate background,
  }) = _PreflightPayOnchainResponse;
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array32(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array32.init() : this(Uint8List(arraySize));
}

/// See [`common::api::qs::UpdatePaymentNote`].
@freezed
class UpdatePaymentNote with _$UpdatePaymentNote {
  const factory UpdatePaymentNote({
    required PaymentIndex index,
    String? note,
  }) = _UpdatePaymentNote;
}
