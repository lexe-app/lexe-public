// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.1.

//
// From: `dart_preamble` in `app-rs-codegen/src/lib.rs`
// ignore_for_file: invalid_internal_annotation, always_use_package_imports, directives_ordering, prefer_const_constructors, sort_unnamed_constructors_first
//

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'app.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'types.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `try_from`, `try_from`

/// Some assorted user/node info. This is kinda hacked together currently just
/// to support account deletion requests.
@freezed
class AppUserInfo with _$AppUserInfo {
  const factory AppUserInfo({
    required String userPk,
    required String nodePk,
    required String nodePkProof,
  }) = _AppUserInfo;
}

/// A unique, client-generated id for payment types (onchain send,
/// ln spontaneous send) that need an extra id for idempotency.
@freezed
class ClientPaymentId with _$ClientPaymentId {
  const ClientPaymentId._();
  const factory ClientPaymentId({
    required U8Array32 id,
  }) = _ClientPaymentId;
  static ClientPaymentId genNew() =>
      AppRs.instance.api.crateFfiTypesClientPaymentIdGenNew();
}

/// Dart-serializable configuration we get from the flutter side.
@freezed
class Config with _$Config {
  const factory Config({
    required DeployEnv deployEnv,
    required Network network,
    required String gatewayUrl,
    required bool useSgx,
    required String baseAppDataDir,
    required bool useMockSecretStore,
    required String userAgent,
  }) = _Config;
}

enum ConfirmationPriority {
  high,
  normal,
  background,
  ;
}

/// See [`common::env::DeployEnv`]
enum DeployEnv {
  dev,
  staging,
  prod,
  ;

  static DeployEnv fromStr({required String s}) =>
      AppRs.instance.api.crateFfiTypesDeployEnvFromStr(s: s);
}

/// A lightning invoice with useful fields parsed out for the flutter frontend.
/// Mirrors the [`LxInvoice`] type.
@freezed
class Invoice with _$Invoice {
  const factory Invoice({
    required String string,
    String? description,
    required int createdAt,
    required int expiresAt,
    int? amountSats,
    required String payeePubkey,
  }) = _Invoice;
}

class LxChannelDetails {
  final String channelId;
  final String counterpartyNodeId;
  final int channelValueSats;
  final bool isUsable;
  final int ourBalanceSats;
  final int outboundCapacitySats;
  final int nextOutboundHtlcLimitSats;
  final int theirBalanceSats;
  final int inboundCapacitySats;

  const LxChannelDetails({
    required this.channelId,
    required this.counterpartyNodeId,
    required this.channelValueSats,
    required this.isUsable,
    required this.ourBalanceSats,
    required this.outboundCapacitySats,
    required this.nextOutboundHtlcLimitSats,
    required this.theirBalanceSats,
    required this.inboundCapacitySats,
  });

  @override
  int get hashCode =>
      channelId.hashCode ^
      counterpartyNodeId.hashCode ^
      channelValueSats.hashCode ^
      isUsable.hashCode ^
      ourBalanceSats.hashCode ^
      outboundCapacitySats.hashCode ^
      nextOutboundHtlcLimitSats.hashCode ^
      theirBalanceSats.hashCode ^
      inboundCapacitySats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LxChannelDetails &&
          runtimeType == other.runtimeType &&
          channelId == other.channelId &&
          counterpartyNodeId == other.counterpartyNodeId &&
          channelValueSats == other.channelValueSats &&
          isUsable == other.isUsable &&
          ourBalanceSats == other.ourBalanceSats &&
          outboundCapacitySats == other.outboundCapacitySats &&
          nextOutboundHtlcLimitSats == other.nextOutboundHtlcLimitSats &&
          theirBalanceSats == other.theirBalanceSats &&
          inboundCapacitySats == other.inboundCapacitySats;
}

/// See [`common::ln::network::LxNetwork`]
enum Network {
  mainnet,
  testnet3,
  testnet4,
  regtest,
  ;

  static Network fromStr({required String s}) =>
      AppRs.instance.api.crateFfiTypesNetworkFromStr(s: s);
}

@freezed
class Offer with _$Offer {
  const factory Offer({
    required String string,
    String? description,
    int? expiresAt,
    int? amountSats,
  }) = _Offer;
}

/// A potential onchain Bitcoin payment.
@freezed
class Onchain with _$Onchain {
  const factory Onchain({
    required String address,
    int? amountSats,
    String? label,
    String? message,
  }) = _Onchain;
}

/// The complete payment info, used in the payment detail page. Mirrors the
/// [`BasicPaymentRs`] type.
@freezed
class Payment with _$Payment {
  const factory Payment({
    required PaymentIndex index,
    required PaymentKind kind,
    required PaymentDirection direction,
    Invoice? invoice,
    String? txid,
    String? replacement,
    int? amountSat,
    required int feesSat,
    required PaymentStatus status,
    required String statusStr,
    String? note,
    required int createdAt,
    int? finalizedAt,
  }) = _Payment;
}

enum PaymentDirection {
  inbound,
  outbound,
  ;
}

/// See [`common::ln::payments::PaymentIndex`].
@freezed
class PaymentIndex with _$PaymentIndex {
  const factory PaymentIndex({
    required String field0,
  }) = _PaymentIndex;
}

enum PaymentKind {
  onchain,
  invoice,
  spontaneous,
  ;
}

@freezed
sealed class PaymentMethod with _$PaymentMethod {
  const PaymentMethod._();

  const factory PaymentMethod.onchain(
    Onchain field0,
  ) = PaymentMethod_Onchain;
  const factory PaymentMethod.invoice(
    Invoice field0,
  ) = PaymentMethod_Invoice;
  const factory PaymentMethod.offer() = PaymentMethod_Offer;
}

enum PaymentStatus {
  pending,
  completed,
  failed,
  ;
}

class RevocableClient {
  final String pubkey;
  final int createdAt;
  final String? label;
  final Scope scope;

  const RevocableClient({
    required this.pubkey,
    required this.createdAt,
    this.label,
    required this.scope,
  });

  @override
  int get hashCode =>
      pubkey.hashCode ^ createdAt.hashCode ^ label.hashCode ^ scope.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RevocableClient &&
          runtimeType == other.runtimeType &&
          pubkey == other.pubkey &&
          createdAt == other.createdAt &&
          label == other.label &&
          scope == other.scope;
}

/// The user's root seed from which we derive all child secrets.
class RootSeed {
  final RootSeedRs inner;

  const RootSeed({
    required this.inner,
  });

  /// Hex-encode the root seed secret. Should only be used for debugging.
  String exposeSecretHex() =>
      AppRs.instance.api.crateFfiTypesRootSeedExposeSecretHex(
        that: this,
      );

  @override
  int get hashCode => inner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RootSeed &&
          runtimeType == other.runtimeType &&
          inner == other.inner;
}

enum Scope {
  all,
  nodeConnect,
  ;
}

/// Just the info we need to display an entry in the payments list UI.
@freezed
class ShortPayment with _$ShortPayment {
  const factory ShortPayment({
    required PaymentIndex index,
    required PaymentKind kind,
    required PaymentDirection direction,
    int? amountSat,
    required PaymentStatus status,
    String? note,
    required int createdAt,
  }) = _ShortPayment;
}

/// Just a `(usize, ShortPayment)`, but packaged in a struct until
/// `flutter_rust_bridge` stops breaking on tuples.
class ShortPaymentAndIndex {
  final int vecIdx;
  final ShortPayment payment;

  const ShortPaymentAndIndex({
    required this.vecIdx,
    required this.payment,
  });

  @override
  int get hashCode => vecIdx.hashCode ^ payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ShortPaymentAndIndex &&
          runtimeType == other.runtimeType &&
          vecIdx == other.vecIdx &&
          payment == other.payment;
}

/// A unique, client-generated id for `open_channel`.
///
/// - Provides idempotency, to avoid opening duplicate channels on
///   `open_channel` retries.
/// - The `ChannelId` is only assigned when the channel finishes negotiation and
///   we build the channel funding txo.
@freezed
class UserChannelId with _$UserChannelId {
  const UserChannelId._();
  const factory UserChannelId({
    required U8Array16 id,
  }) = _UserChannelId;
  static UserChannelId genNew() =>
      AppRs.instance.api.crateFfiTypesUserChannelIdGenNew();
}
