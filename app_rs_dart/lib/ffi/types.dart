// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

//
// From: `dart_preamble` in `app-rs-codegen/src/lib.rs`
// ignore_for_file: invalid_internal_annotation, always_use_package_imports, directives_ordering, prefer_const_constructors, sort_unnamed_constructors_first
//

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'app.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'types.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `into_inner`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `try_from`, `try_from`, `try_from`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `env_config`, `env_db_config`, `wallet_env`

/// Some assorted user/node info. This is kinda hacked together currently just
/// to support account deletion requests.
///
/// flutter_rust_bridge:dart_metadata=("freezed")
@freezed
sealed class AppUserInfo with _$AppUserInfo {
  const factory AppUserInfo({
    required String userPk,
    required String nodePk,
    required String nodePkProof,
  }) = _AppUserInfo;
}

class BackupInfo {
  final GDriveStatus gdriveStatus;

  const BackupInfo({required this.gdriveStatus});

  @override
  int get hashCode => gdriveStatus.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BackupInfo &&
          runtimeType == other.runtimeType &&
          gdriveStatus == other.gdriveStatus;
}

/// A unique, client-generated id for payment types (onchain send,
/// ln spontaneous send) that need an extra id for idempotency.
///
/// flutter_rust_bridge:dart_metadata=("freezed")
@freezed
sealed class ClientPaymentId with _$ClientPaymentId {
  const ClientPaymentId._();
  const factory ClientPaymentId({required U8Array32 id}) = _ClientPaymentId;

  /// flutter_rust_bridge:sync
  static ClientPaymentId genNew() =>
      AppRs.instance.api.crateFfiTypesClientPaymentIdGenNew();
}

/// Dart-serializable configuration we get from the flutter side.
///
/// flutter_rust_bridge:dart_metadata=("freezed")
@freezed
sealed class Config with _$Config {
  const Config._();
  const factory Config({
    required DeployEnv deployEnv,
    required Network network,
    required String gatewayUrl,
    required bool useSgx,
    required String lexeDataDir,
    required bool useMockSecretStore,
    required String userAgent,
  }) = _Config;

  /// Validates the config combination. Panics if the combination is invalid.
  Future<void> validate() =>
      AppRs.instance.api.crateFfiTypesConfigValidate(that: this);
}

enum ConfirmationPriority { high, normal, background }

/// See [`common::env::DeployEnv`]
///
/// flutter_rust_bridge:dart_metadata=("freezed")
enum DeployEnv {
  dev,
  staging,
  prod;

  /// flutter_rust_bridge:sync
  static DeployEnv fromStr({required String s}) =>
      AppRs.instance.api.crateFfiTypesDeployEnvFromStr(s: s);

  /// Returns the gateway URL for this deploy environment.
  ///
  /// A custom gateway URL (e.g. from env) can be provided for dev.
  ///
  /// flutter_rust_bridge:sync
  String gatewayUrl({String? devGatewayUrl}) =>
      AppRs.instance.api.crateFfiTypesDeployEnvGatewayUrl(
        that: this,
        devGatewayUrl: devGatewayUrl,
      );
}

class GDriveSignupCredentials {
  /// The user's backup password, used to encrypt their [`RootSeed`] backup
  /// on Google Drive.
  final String backupPassword;

  /// The google auth code passed to the node enclave during provisioning.
  final String googleAuthCode;

  const GDriveSignupCredentials({
    required this.backupPassword,
    required this.googleAuthCode,
  });

  @override
  int get hashCode => backupPassword.hashCode ^ googleAuthCode.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GDriveSignupCredentials &&
          runtimeType == other.runtimeType &&
          backupPassword == other.backupPassword &&
          googleAuthCode == other.googleAuthCode;
}

@freezed
sealed class GDriveStatus with _$GDriveStatus {
  const GDriveStatus._();

  const factory GDriveStatus.ok() = GDriveStatus_Ok;
  const factory GDriveStatus.error(String field0) = GDriveStatus_Error;
  const factory GDriveStatus.disabled() = GDriveStatus_Disabled;
}

/// A lightning invoice with useful fields parsed out for the flutter frontend.
/// Mirrors the [`LxInvoice`] type.
///
/// flutter_rust_bridge:dart_metadata=("freezed")
@freezed
sealed class Invoice with _$Invoice {
  const factory Invoice({
    required String string,
    String? description,
    required int createdAt,
    required int expiresAt,
    int? amountSats,
    required String payeePubkey,
  }) = _Invoice;
}

class LnurlPayRequest {
  final String callback;
  final int minSendableMsat;
  final int maxSendableMsat;
  final LnurlPayRequestMetadata metadata;

  const LnurlPayRequest({
    required this.callback,
    required this.minSendableMsat,
    required this.maxSendableMsat,
    required this.metadata,
  });

  @override
  int get hashCode =>
      callback.hashCode ^
      minSendableMsat.hashCode ^
      maxSendableMsat.hashCode ^
      metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayRequest &&
          runtimeType == other.runtimeType &&
          callback == other.callback &&
          minSendableMsat == other.minSendableMsat &&
          maxSendableMsat == other.maxSendableMsat &&
          metadata == other.metadata;
}

class LnurlPayRequestMetadata {
  final String description;
  final String? longDescription;
  final String? imagePngBase64;
  final String? imageJpegBase64;
  final String? identifier;
  final String? email;
  final U8Array32 descriptionHash;
  final String raw;

  const LnurlPayRequestMetadata({
    required this.description,
    this.longDescription,
    this.imagePngBase64,
    this.imageJpegBase64,
    this.identifier,
    this.email,
    required this.descriptionHash,
    required this.raw,
  });

  @override
  int get hashCode =>
      description.hashCode ^
      longDescription.hashCode ^
      imagePngBase64.hashCode ^
      imageJpegBase64.hashCode ^
      identifier.hashCode ^
      email.hashCode ^
      descriptionHash.hashCode ^
      raw.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayRequestMetadata &&
          runtimeType == other.runtimeType &&
          description == other.description &&
          longDescription == other.longDescription &&
          imagePngBase64 == other.imagePngBase64 &&
          imageJpegBase64 == other.imageJpegBase64 &&
          identifier == other.identifier &&
          email == other.email &&
          descriptionHash == other.descriptionHash &&
          raw == other.raw;
}

class LxChannelDetails {
  final String channelId;
  final String counterpartyNodeId;
  final int channelValueSats;
  final bool isUsable;
  final int ourBalanceSats;
  final int outboundCapacitySats;
  final int nextOutboundHtlcLimitSats;
  final int theirBalanceSats;
  final int inboundCapacitySats;

  const LxChannelDetails({
    required this.channelId,
    required this.counterpartyNodeId,
    required this.channelValueSats,
    required this.isUsable,
    required this.ourBalanceSats,
    required this.outboundCapacitySats,
    required this.nextOutboundHtlcLimitSats,
    required this.theirBalanceSats,
    required this.inboundCapacitySats,
  });

  @override
  int get hashCode =>
      channelId.hashCode ^
      counterpartyNodeId.hashCode ^
      channelValueSats.hashCode ^
      isUsable.hashCode ^
      ourBalanceSats.hashCode ^
      outboundCapacitySats.hashCode ^
      nextOutboundHtlcLimitSats.hashCode ^
      theirBalanceSats.hashCode ^
      inboundCapacitySats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LxChannelDetails &&
          runtimeType == other.runtimeType &&
          channelId == other.channelId &&
          counterpartyNodeId == other.counterpartyNodeId &&
          channelValueSats == other.channelValueSats &&
          isUsable == other.isUsable &&
          ourBalanceSats == other.ourBalanceSats &&
          outboundCapacitySats == other.outboundCapacitySats &&
          nextOutboundHtlcLimitSats == other.nextOutboundHtlcLimitSats &&
          theirBalanceSats == other.theirBalanceSats &&
          inboundCapacitySats == other.inboundCapacitySats;
}

/// See [`common::ln::network::LxNetwork`]
enum Network {
  mainnet,
  testnet3,
  testnet4,
  regtest;

  /// flutter_rust_bridge:sync
  static Network fromStr({required String s}) =>
      AppRs.instance.api.crateFfiTypesNetworkFromStr(s: s);
}

/// A lightning offer with useful fields parsed out for the flutter frontend.
/// Mirrors the [`LxOffer`] type.
///
/// flutter_rust_bridge:dart_metadata=("freezed")
@freezed
sealed class Offer with _$Offer {
  const factory Offer({
    required String string,
    String? description,
    int? expiresAt,
    int? amountSats,
    String? payee,
    String? payeePubkey,
  }) = _Offer;
}

/// A potential onchain Bitcoin payment.
///
/// flutter_rust_bridge:dart_metadata=("freezed")
@freezed
sealed class Onchain with _$Onchain {
  const factory Onchain({
    required String address,
    int? amountSats,
    String? label,
    String? message,
  }) = _Onchain;
}

/// The complete payment info, used in the payment detail page. Mirrors the
/// [`BasicPaymentV1Rs`] type.
///
/// flutter_rust_bridge:dart_metadata=("freezed")
@freezed
sealed class Payment with _$Payment {
  const factory Payment({
    required PaymentCreatedIndex index,
    required PaymentKind kind,
    required PaymentDirection direction,
    Invoice? invoice,
    String? offerId,
    Offer? offer,
    String? txid,
    String? replacement,
    int? amountSat,
    required int feesSat,
    required PaymentStatus status,
    required String statusStr,
    String? description,
    String? note,
    String? payerName,
    String? payerNote,
    required int createdAt,
    int? finalizedAt,
  }) = _Payment;
}

/// See [`lexe_api::types::payments::PaymentCreatedIndex`].
///
/// flutter_rust_bridge:dart_metadata=("freezed")
@freezed
sealed class PaymentCreatedIndex with _$PaymentCreatedIndex {
  const factory PaymentCreatedIndex({required String field0}) =
      _PaymentCreatedIndex;
}

enum PaymentDirection { inbound, outbound, info }

@freezed
sealed class PaymentKind with _$PaymentKind {
  const PaymentKind._();

  const factory PaymentKind.onchain() = PaymentKind_Onchain;
  const factory PaymentKind.invoice() = PaymentKind_Invoice;
  const factory PaymentKind.offer() = PaymentKind_Offer;
  const factory PaymentKind.spontaneous() = PaymentKind_Spontaneous;
  const factory PaymentKind.waivedChannelFee() = PaymentKind_WaivedChannelFee;
  const factory PaymentKind.waivedLiquidityFee() =
      PaymentKind_WaivedLiquidityFee;
  const factory PaymentKind.unknown(String field0) = PaymentKind_Unknown;
}

@freezed
sealed class PaymentMethod with _$PaymentMethod {
  const PaymentMethod._();

  const factory PaymentMethod.onchain(Onchain field0) = PaymentMethod_Onchain;
  const factory PaymentMethod.invoice(Invoice field0) = PaymentMethod_Invoice;
  const factory PaymentMethod.offer(Offer field0) = PaymentMethod_Offer;
  const factory PaymentMethod.lnurlPayRequest(LnurlPayRequest field0) =
      PaymentMethod_LnurlPayRequest;
}

enum PaymentStatus { pending, completed, failed }

class RevocableClient {
  final String pubkey;
  final int createdAt;
  final String? label;
  final Scope scope;

  const RevocableClient({
    required this.pubkey,
    required this.createdAt,
    this.label,
    required this.scope,
  });

  @override
  int get hashCode =>
      pubkey.hashCode ^ createdAt.hashCode ^ label.hashCode ^ scope.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RevocableClient &&
          runtimeType == other.runtimeType &&
          pubkey == other.pubkey &&
          createdAt == other.createdAt &&
          label == other.label &&
          scope == other.scope;
}

/// The user's root seed from which we derive all child secrets.
class RootSeed {
  final RootSeedRs inner;

  const RootSeed({required this.inner});

  /// Hex-encode the root seed secret. Should only be used for debugging.
  ///
  /// flutter_rust_bridge:sync
  String exposeSecretHex() =>
      AppRs.instance.api.crateFfiTypesRootSeedExposeSecretHex(that: this);

  /// flutter_rust_bridge:sync
  static RootSeed fromMnemonic({required List<String> mnemonic}) =>
      AppRs.instance.api.crateFfiTypesRootSeedFromMnemonic(mnemonic: mnemonic);

  /// Generate a new RootSeed from the secure system RNG.
  ///
  /// flutter_rust_bridge:sync
  static RootSeed fromSysRng() =>
      AppRs.instance.api.crateFfiTypesRootSeedFromSysRng();

  /// Return the 24-word BIP-39 seed phrase for this root seed.
  ///
  /// flutter_rust_bridge:sync
  List<String> seedPhrase() =>
      AppRs.instance.api.crateFfiTypesRootSeedSeedPhrase(that: this);

  @override
  int get hashCode => inner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RootSeed &&
          runtimeType == other.runtimeType &&
          inner == other.inner;
}

enum Scope { all, nodeConnect }

/// Just the info we need to display an entry in the payments list UI.
///
/// flutter_rust_bridge:dart_metadata=("freezed")
@freezed
sealed class ShortPayment with _$ShortPayment {
  const factory ShortPayment({
    required PaymentCreatedIndex index,
    required PaymentKind kind,
    required PaymentDirection direction,
    int? amountSat,
    required PaymentStatus status,
    String? description,
    String? note,
    required int createdAt,
  }) = _ShortPayment;
}

/// A unique, client-generated id for `open_channel`.
///
/// - Provides idempotency, to avoid opening duplicate channels on
///   `open_channel` retries.
/// - The `ChannelId` is only assigned when the channel finishes negotiation and
///   we build the channel funding txo.
///
/// flutter_rust_bridge:dart_metadata=("freezed")
@freezed
sealed class UserChannelId with _$UserChannelId {
  const UserChannelId._();
  const factory UserChannelId({required U8Array16 id}) = _UserChannelId;

  /// flutter_rust_bridge:sync
  static UserChannelId genNew() =>
      AppRs.instance.api.crateFfiTypesUserChannelIdGenNew();
}

class Username {
  final String field0;

  const Username({required this.field0});

  /// flutter_rust_bridge:sync
  static Username parse({required String s}) =>
      AppRs.instance.api.crateFfiTypesUsernameParse(s: s);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Username &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}
