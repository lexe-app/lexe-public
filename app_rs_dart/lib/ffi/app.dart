// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.2.0.

//
// From: `dart_preamble` in `app-rs-codegen/src/lib.rs`
// ignore_for_file: invalid_internal_annotation, always_use_package_imports, directives_ordering, prefer_const_constructors, sort_unnamed_constructors_first
//

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'api.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'settings.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `new`

// Rust type: RustOpaqueNom<App>
abstract class App implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<RootSeedRs>
abstract class RootSeedRs implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<SettingsDbRs>
abstract class SettingsDbRs implements RustOpaqueInterface {}

/// The `AppHandle` is a Dart representation of an [`App`] instance.
class AppHandle {
  final App inner;

  const AppHandle({
    required this.inner,
  });

  Future<CreateInvoiceResponse> createInvoice(
          {required CreateInvoiceRequest req}) =>
      AppRs.instance.api
          .crateFfiAppAppHandleCreateInvoice(that: this, req: req);

  /// Delete both the local payment state and the on-disk payment db.
  Future<void> deletePaymentDb() =>
      AppRs.instance.api.crateFfiAppAppHandleDeletePaymentDb(
        that: this,
      );

  Future<FiatRates> fiatRates() =>
      AppRs.instance.api.crateFfiAppAppHandleFiatRates(
        that: this,
      );

  Future<String> getAddress() =>
      AppRs.instance.api.crateFfiAppAppHandleGetAddress(
        that: this,
      );

  ShortPaymentAndIndex? getFinalizedNotJunkShortPaymentByScrollIdx(
          {required int scrollIdx}) =>
      AppRs.instance.api
          .crateFfiAppAppHandleGetFinalizedNotJunkShortPaymentByScrollIdx(
              that: this, scrollIdx: scrollIdx);

  ShortPaymentAndIndex? getFinalizedShortPaymentByScrollIdx(
          {required int scrollIdx}) =>
      AppRs.instance.api
          .crateFfiAppAppHandleGetFinalizedShortPaymentByScrollIdx(
              that: this, scrollIdx: scrollIdx);

  int getNumFinalizedNotJunkPayments() =>
      AppRs.instance.api.crateFfiAppAppHandleGetNumFinalizedNotJunkPayments(
        that: this,
      );

  int getNumFinalizedPayments() =>
      AppRs.instance.api.crateFfiAppAppHandleGetNumFinalizedPayments(
        that: this,
      );

  int getNumPayments() => AppRs.instance.api.crateFfiAppAppHandleGetNumPayments(
        that: this,
      );

  int getNumPendingNotJunkPayments() =>
      AppRs.instance.api.crateFfiAppAppHandleGetNumPendingNotJunkPayments(
        that: this,
      );

  int getNumPendingPayments() =>
      AppRs.instance.api.crateFfiAppAppHandleGetNumPendingPayments(
        that: this,
      );

  Payment? getPaymentByVecIdx({required int vecIdx}) => AppRs.instance.api
      .crateFfiAppAppHandleGetPaymentByVecIdx(that: this, vecIdx: vecIdx);

  ShortPaymentAndIndex? getPendingNotJunkShortPaymentByScrollIdx(
          {required int scrollIdx}) =>
      AppRs.instance.api
          .crateFfiAppAppHandleGetPendingNotJunkShortPaymentByScrollIdx(
              that: this, scrollIdx: scrollIdx);

  ShortPaymentAndIndex? getPendingShortPaymentByScrollIdx(
          {required int scrollIdx}) =>
      AppRs.instance.api.crateFfiAppAppHandleGetPendingShortPaymentByScrollIdx(
          that: this, scrollIdx: scrollIdx);

  ShortPaymentAndIndex? getShortPaymentByScrollIdx({required int scrollIdx}) =>
      AppRs.instance.api.crateFfiAppAppHandleGetShortPaymentByScrollIdx(
          that: this, scrollIdx: scrollIdx);

  Future<int?> getVecIdxByPaymentIndex({required PaymentIndex paymentIndex}) =>
      AppRs.instance.api.crateFfiAppAppHandleGetVecIdxByPaymentIndex(
          that: this, paymentIndex: paymentIndex);

  Future<ListChannelsResponse> listChannels() =>
      AppRs.instance.api.crateFfiAppAppHandleListChannels(
        that: this,
      );

  static Future<AppHandle?> load({required Config config}) =>
      AppRs.instance.api.crateFfiAppAppHandleLoad(config: config);

  Future<NodeInfo> nodeInfo() =>
      AppRs.instance.api.crateFfiAppAppHandleNodeInfo(
        that: this,
      );

  Future<OpenChannelResponse> openChannel({required OpenChannelRequest req}) =>
      AppRs.instance.api.crateFfiAppAppHandleOpenChannel(that: this, req: req);

  Future<PayInvoiceResponse> payInvoice({required PayInvoiceRequest req}) =>
      AppRs.instance.api.crateFfiAppAppHandlePayInvoice(that: this, req: req);

  Future<PayOnchainResponse> payOnchain({required PayOnchainRequest req}) =>
      AppRs.instance.api.crateFfiAppAppHandlePayOnchain(that: this, req: req);

  Future<PreflightPayInvoiceResponse> preflightPayInvoice(
          {required PreflightPayInvoiceRequest req}) =>
      AppRs.instance.api
          .crateFfiAppAppHandlePreflightPayInvoice(that: this, req: req);

  Future<PreflightPayOnchainResponse> preflightPayOnchain(
          {required PreflightPayOnchainRequest req}) =>
      AppRs.instance.api
          .crateFfiAppAppHandlePreflightPayOnchain(that: this, req: req);

  static Future<AppHandle> restore(
          {required Config config,
          required String googleAuthCode,
          required RootSeed rootSeed}) =>
      AppRs.instance.api.crateFfiAppAppHandleRestore(
          config: config, googleAuthCode: googleAuthCode, rootSeed: rootSeed);

  SettingsDb settingsDb() => AppRs.instance.api.crateFfiAppAppHandleSettingsDb(
        that: this,
      );

  static Future<AppHandle> signup(
          {required Config config,
          required String googleAuthCode,
          required String password}) =>
      AppRs.instance.api.crateFfiAppAppHandleSignup(
          config: config, googleAuthCode: googleAuthCode, password: password);

  /// Sync the local payment DB to the remote node.
  ///
  /// Returns `true` if any payment changed, so we know whether to reload the
  /// payment list UI.
  Future<bool> syncPayments() =>
      AppRs.instance.api.crateFfiAppAppHandleSyncPayments(
        that: this,
      );

  Future<void> updatePaymentNote({required UpdatePaymentNote req}) =>
      AppRs.instance.api
          .crateFfiAppAppHandleUpdatePaymentNote(that: this, req: req);

  @override
  int get hashCode => inner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AppHandle &&
          runtimeType == other.runtimeType &&
          inner == other.inner;
}

class U8Array16 extends NonGrowableListView<int> {
  static const arraySize = 16;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array16(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array16.init() : this(Uint8List(arraySize));
}
