// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

//
// From: `dart_preamble` in `app-rs-codegen/src/lib.rs`
// ignore_for_file: invalid_internal_annotation, always_use_package_imports, directives_ordering, prefer_const_constructors, sort_unnamed_constructors_first
//

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'api.dart';
import 'app_data.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'settings.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `new`

// Rust type: RustOpaqueNom<App>
abstract class App implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<WritebackDbRs < SettingsRs >>
abstract class WritebackDbRsSettingsRs implements RustOpaqueInterface {}

/// The `AppHandle` is a Dart representation of an [`App`] instance.
class AppHandle {
  final App inner;

  const AppHandle({required this.inner});

  /// flutter_rust_bridge:sync
  AppDataDb appDataDb() =>
      AppRs.instance.api.crateFfiAppAppHandleAppDataDb(that: this);

  Future<BackupInfo> backupInfo() =>
      AppRs.instance.api.crateFfiAppAppHandleBackupInfo(that: this);

  Future<void> closeChannel({required CloseChannelRequest req}) =>
      AppRs.instance.api.crateFfiAppAppHandleCloseChannel(that: this, req: req);

  Future<CreateClientResponse> createClient({
    required CreateClientRequest req,
  }) =>
      AppRs.instance.api.crateFfiAppAppHandleCreateClient(that: this, req: req);

  Future<CreateInvoiceResponse> createInvoice({
    required CreateInvoiceRequest req,
  }) => AppRs.instance.api.crateFfiAppAppHandleCreateInvoice(
    that: this,
    req: req,
  );

  Future<CreateOfferResponse> createOffer({required CreateOfferRequest req}) =>
      AppRs.instance.api.crateFfiAppAppHandleCreateOffer(that: this, req: req);

  /// Delete both the local payment state and the on-disk payment db.
  Future<void> deletePaymentDb() =>
      AppRs.instance.api.crateFfiAppAppHandleDeletePaymentDb(that: this);

  Future<FiatRates> fiatRates() =>
      AppRs.instance.api.crateFfiAppAppHandleFiatRates(that: this);

  Future<String> getAddress() =>
      AppRs.instance.api.crateFfiAppAppHandleGetAddress(that: this);

  /// flutter_rust_bridge:sync
  ShortPayment? getFinalizedNotJunkShortPaymentByScrollIndex({
    required int scrollIdx,
  }) => AppRs.instance.api
      .crateFfiAppAppHandleGetFinalizedNotJunkShortPaymentByScrollIndex(
        that: this,
        scrollIdx: scrollIdx,
      );

  /// flutter_rust_bridge:sync
  ShortPayment? getFinalizedShortPaymentByScrollIndex({
    required int scrollIdx,
  }) => AppRs.instance.api
      .crateFfiAppAppHandleGetFinalizedShortPaymentByScrollIndex(
        that: this,
        scrollIdx: scrollIdx,
      );

  /// Get the [`HumanAddress`] for the user and if it is updatable.
  Future<HumanAddress> getHumanAddress() =>
      AppRs.instance.api.crateFfiAppAppHandleGetHumanAddress(that: this);

  /// flutter_rust_bridge:sync
  int getNumFinalizedNotJunkPayments() => AppRs.instance.api
      .crateFfiAppAppHandleGetNumFinalizedNotJunkPayments(that: this);

  /// flutter_rust_bridge:sync
  int getNumFinalizedPayments() => AppRs.instance.api
      .crateFfiAppAppHandleGetNumFinalizedPayments(that: this);

  /// flutter_rust_bridge:sync
  int getNumPayments() =>
      AppRs.instance.api.crateFfiAppAppHandleGetNumPayments(that: this);

  /// flutter_rust_bridge:sync
  int getNumPendingNotJunkPayments() => AppRs.instance.api
      .crateFfiAppAppHandleGetNumPendingNotJunkPayments(that: this);

  /// flutter_rust_bridge:sync
  int getNumPendingPayments() =>
      AppRs.instance.api.crateFfiAppAppHandleGetNumPendingPayments(that: this);

  /// flutter_rust_bridge:sync
  Payment? getPaymentByCreatedIndex({
    required PaymentCreatedIndex createdIdx,
  }) => AppRs.instance.api.crateFfiAppAppHandleGetPaymentByCreatedIndex(
    that: this,
    createdIdx: createdIdx,
  );

  /// flutter_rust_bridge:sync
  ShortPayment? getPendingNotJunkShortPaymentByScrollIndex({
    required int scrollIdx,
  }) => AppRs.instance.api
      .crateFfiAppAppHandleGetPendingNotJunkShortPaymentByScrollIndex(
        that: this,
        scrollIdx: scrollIdx,
      );

  /// flutter_rust_bridge:sync
  ShortPayment? getPendingShortPaymentByScrollIndex({required int scrollIdx}) =>
      AppRs.instance.api
          .crateFfiAppAppHandleGetPendingShortPaymentByScrollIndex(
            that: this,
            scrollIdx: scrollIdx,
          );

  /// flutter_rust_bridge:sync
  ShortPayment? getShortPaymentByScrollIndex({required int scrollIdx}) =>
      AppRs.instance.api.crateFfiAppAppHandleGetShortPaymentByScrollIndex(
        that: this,
        scrollIdx: scrollIdx,
      );

  Future<String> listBroadcastedTxs() =>
      AppRs.instance.api.crateFfiAppAppHandleListBroadcastedTxs(that: this);

  Future<ListChannelsResponse> listChannels() =>
      AppRs.instance.api.crateFfiAppAppHandleListChannels(that: this);

  Future<List<RevocableClient>> listClients() =>
      AppRs.instance.api.crateFfiAppAppHandleListClients(that: this);

  static Future<AppHandle?> load({required Config config}) =>
      AppRs.instance.api.crateFfiAppAppHandleLoad(config: config);

  Future<NodeInfo> nodeInfo() =>
      AppRs.instance.api.crateFfiAppAppHandleNodeInfo(that: this);

  Future<OpenChannelResponse> openChannel({required OpenChannelRequest req}) =>
      AppRs.instance.api.crateFfiAppAppHandleOpenChannel(that: this, req: req);

  Future<PayInvoiceResponse> payInvoice({required PayInvoiceRequest req}) =>
      AppRs.instance.api.crateFfiAppAppHandlePayInvoice(that: this, req: req);

  Future<PayOfferResponse> payOffer({required PayOfferRequest req}) =>
      AppRs.instance.api.crateFfiAppAppHandlePayOffer(that: this, req: req);

  Future<PayOnchainResponse> payOnchain({required PayOnchainRequest req}) =>
      AppRs.instance.api.crateFfiAppAppHandlePayOnchain(that: this, req: req);

  Future<PreflightCloseChannelResponse> preflightCloseChannel({
    required CloseChannelRequest req,
  }) => AppRs.instance.api.crateFfiAppAppHandlePreflightCloseChannel(
    that: this,
    req: req,
  );

  Future<PreflightOpenChannelResponse> preflightOpenChannel({
    required PreflightOpenChannelRequest req,
  }) => AppRs.instance.api.crateFfiAppAppHandlePreflightOpenChannel(
    that: this,
    req: req,
  );

  Future<PreflightPayInvoiceResponse> preflightPayInvoice({
    required PreflightPayInvoiceRequest req,
  }) => AppRs.instance.api.crateFfiAppAppHandlePreflightPayInvoice(
    that: this,
    req: req,
  );

  Future<PreflightPayOfferResponse> preflightPayOffer({
    required PreflightPayOfferRequest req,
  }) => AppRs.instance.api.crateFfiAppAppHandlePreflightPayOffer(
    that: this,
    req: req,
  );

  Future<PreflightPayOnchainResponse> preflightPayOnchain({
    required PreflightPayOnchainRequest req,
  }) => AppRs.instance.api.crateFfiAppAppHandlePreflightPayOnchain(
    that: this,
    req: req,
  );

  Future<void> provision() =>
      AppRs.instance.api.crateFfiAppAppHandleProvision(that: this);

  /// Resolve a (possible) [`PaymentUri`] string that we just
  /// scanned/pasted into the best [`PaymentMethod`] for us to pay.
  ///
  /// [`PaymentUri`]: payment_uri::PaymentUri
  Future<PaymentMethod> resolveBest({
    required Network network,
    required String uriStr,
  }) => AppRs.instance.api.crateFfiAppAppHandleResolveBest(
    that: this,
    network: network,
    uriStr: uriStr,
  );

  /// Resolve a [`LnurlPayRequest`] that we just received + the amount in
  /// msats. After resolving, we can use the [`Invoice`] to pay the
  /// invoice.
  Future<Invoice> resolveLnurlPayRequest({
    required LnurlPayRequest req,
    required int amountMsats,
    String? comment,
  }) => AppRs.instance.api.crateFfiAppAppHandleResolveLnurlPayRequest(
    that: this,
    req: req,
    amountMsats: amountMsats,
    comment: comment,
  );

  static Future<AppHandle> restore({
    required Config config,
    String? googleAuthCode,
    required RootSeed rootSeed,
  }) => AppRs.instance.api.crateFfiAppAppHandleRestore(
    config: config,
    googleAuthCode: googleAuthCode,
    rootSeed: rootSeed,
  );

  /// flutter_rust_bridge:sync
  SettingsDb settingsDb() =>
      AppRs.instance.api.crateFfiAppAppHandleSettingsDb(that: this);

  static Future<AppHandle> signup({
    required Config config,
    required RootSeed rootSeed,
    String? partner,
    String? signupCode,
    GDriveSignupCredentials? gdriveSignupCreds,
  }) => AppRs.instance.api.crateFfiAppAppHandleSignup(
    config: config,
    rootSeed: rootSeed,
    partner: partner,
    signupCode: signupCode,
    gdriveSignupCreds: gdriveSignupCreds,
  );

  /// Sync the local payment DB to the remote node.
  ///
  /// Returns `true` if any payment changed, so we know whether to reload the
  /// payment list UI.
  Future<bool> syncPayments() =>
      AppRs.instance.api.crateFfiAppAppHandleSyncPayments(that: this);

  Future<void> updateClient({required UpdateClientRequest req}) =>
      AppRs.instance.api.crateFfiAppAppHandleUpdateClient(that: this, req: req);

  Future<HumanAddress> updateHumanAddress({required Username username}) => AppRs
      .instance
      .api
      .crateFfiAppAppHandleUpdateHumanAddress(that: this, username: username);

  Future<void> updatePaymentNote({required UpdatePaymentNote req}) => AppRs
      .instance
      .api
      .crateFfiAppAppHandleUpdatePaymentNote(that: this, req: req);

  /// flutter_rust_bridge:sync
  AppUserInfo walletUser() =>
      AppRs.instance.api.crateFfiAppAppHandleWalletUser(that: this);

  @override
  int get hashCode => inner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AppHandle &&
          runtimeType == other.runtimeType &&
          inner == other.inner;
}

class U8Array16 extends NonGrowableListView<int> {
  static const arraySize = 16;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array16(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array16.init() : this(Uint8List(arraySize));
}
