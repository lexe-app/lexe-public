use anyhow::{anyhow, bail, ensure, Context};
use bitcoin::{
    bech32::u5,
    blockdata::{
        locktime::PackedLockTime,
        script::Script,
        transaction::{Transaction, TxOut},
    },
    secp256k1::{
        ecdh::SharedSecret,
        ecdsa::{RecoverableSignature, Signature},
        scalar::Scalar,
        PublicKey, Secp256k1, Signing,
    },
    util::address::{Address, Payload},
};
use common::{api::NodePk, rng::Crng, root_seed::RootSeed};
use lightning::{
    ln::{
        msgs::{DecodeError, UnsignedGossipMessage},
        script::ShutdownScript,
    },
    sign::{
        EntropySource, InMemorySigner, KeyMaterial, KeysManager, NodeSigner,
        Recipient, SignerProvider, SpendableOutputDescriptor,
    },
};
use secrecy::ExposeSecret;
use tracing::debug;

/// Wraps LDK's [`KeysManager`] to provide the following:
///
/// 1) We have a simplified init API and a `get_node_pk` convenience method.
/// 2) Mirroring [ldk-node's implementation], we override
///    [`get_destination_script`] and [`get_shutdown_scriptpubkey`] so that LDK
///    gets addresses managed by BDK whenever it has the opportunity to close a
///    channel to a [`StaticOutput`] (usually (or only?) a cooperative close).
///    This allows us to avoid the on-chain fees incurred by a tx that sweeps
///    the output descriptors given to us in the [`SpendableOutputs`] event.
///
/// [ldk-node's implementation]: https://github.com/lightningdevkit/ldk-node/blob/3c7dac9d01ffdf66705b4a27ac699ab3d83c77f6/src/wallet.rs#L461-L484
/// [`get_destination_script`]: SignerProvider::get_destination_script.
/// [`get_shutdown_scriptpubkey`]: SignerProvider::get_shutdown_scriptpubkey.
/// [`StaticOutput`]: lightning::sign::SpendableOutputDescriptor::StaticOutput
/// [`SpendableOutputs`]: lightning::events::Event::SpendableOutputs
pub struct LexeKeysManager {
    inner: KeysManager,
    /// A destination script owned by our BDK wallet, returned by
    /// [`SignerProvider::get_destination_script`].
    destination_script: Script,
    /// A shutdown script pubkey owned by our BDK wallet, returned by
    /// [`SignerProvider::get_shutdown_scriptpubkey`].
    shutdown_scriptpubkey: ShutdownScript,
}

impl LexeKeysManager {
    /// Initialize a [`LexeKeysManager`] from a [`RootSeed`] without supplying a
    /// pubkey to check the derived pubkey against.
    ///
    /// Assumes `recv_address` was generated by our BDK wallet.
    pub fn unchecked_init<R: Crng>(
        rng: &mut R,
        root_seed: &RootSeed,
        recv_address: Address,
    ) -> anyhow::Result<Self> {
        let ldk_seed = root_seed.derive_ldk_seed(rng);
        // KeysManager requires a "starting_time_secs" and "starting_time_nanos"
        // to seed an CRNG. We just provide random values from our system CRNG.
        let random_secs = rng.next_u64();
        let random_nanos = rng.next_u32();
        let inner = KeysManager::new(
            ldk_seed.expose_secret(),
            random_secs,
            random_nanos,
        );

        // Construct the shutdown scripts
        let (destination_script, shutdown_scriptpubkey) =
            Self::shutdown_scripts_from_recv_address(recv_address)
                .context("Error getting receive scripts")?;

        Ok(Self {
            inner,
            destination_script,
            shutdown_scriptpubkey,
        })
    }

    /// Initialize a `LexeKeysManager` from a given [`RootSeed`]. Verifies that
    /// the derived node public key matches `given_pk`.
    ///
    /// Assumes `recv_address` was generated by our BDK wallet.
    pub fn init<R: Crng>(
        rng: &mut R,
        given_pk: &NodePk,
        root_seed: &RootSeed,
        recv_address: Address,
    ) -> anyhow::Result<Self> {
        // Build the KeysManager from the LDK seed derived from the root seed
        let ldk_seed = root_seed.derive_ldk_seed(rng);

        // KeysManager requires a "starting_time_secs" and "starting_time_nanos"
        // to seed an CRNG. We just provide random values from our system CRNG.
        let random_secs = rng.next_u64();
        let random_nanos = rng.next_u32();
        let inner = KeysManager::new(
            ldk_seed.expose_secret(),
            random_secs,
            random_nanos,
        );

        // Construct the shutdown scripts
        let (destination_script, shutdown_scriptpubkey) =
            Self::shutdown_scripts_from_recv_address(recv_address)
                .context("Error getting receive scripts")?;

        // Construct the LexeKeysManager, but validation isn't done yet
        let keys_manager = Self {
            inner,
            destination_script,
            shutdown_scriptpubkey,
        };

        // Derive the node_pk from the inner KeysManager
        let derived_pk = keys_manager.get_node_pk();

        // Check the given pk against the derived one
        ensure!(
            given_pk == &derived_pk,
            "Derived pk doesn't match the given pk"
        );

        // Validation complete, finally return the LexeKeysManager
        Ok(keys_manager)
    }

    /// Helper to construct the shutdown scripts.
    fn shutdown_scripts_from_recv_address(
        recv_address: Address,
    ) -> anyhow::Result<(Script, ShutdownScript)> {
        let destination_script = recv_address.script_pubkey();
        let shutdown_scriptpubkey = match recv_address.payload {
            Payload::WitnessProgram { version, program } =>
                ShutdownScript::new_witness_program(version, &program)
                    .map_err(|e| anyhow!("Invalid shutdown script: {e:?}"))?,
            _ => bail!("Derived address should've been segwit address!"),
        };

        Ok((destination_script, shutdown_scriptpubkey))
    }

    pub fn get_node_pk(&self) -> NodePk {
        self.inner
            .get_node_id(Recipient::Node)
            .map(NodePk)
            .expect("Always succeeds when called with Recipient::Node")
    }

    /// Overrides [`KeysManager::spend_spendable_outputs`] so that we don't try
    /// to spend any [`StaticOutput`]s given to us in the `descriptors`
    /// parameter, since these are already managed by BDK.
    ///
    /// Based off of [ldk-node's implementation].
    ///
    /// [`StaticOutput`]: lightning::sign::SpendableOutputDescriptor::StaticOutput
    /// [ldk-node's implementation]: https://github.com/lightningdevkit/ldk-node/blob/3c7dac9d01ffdf66705b4a27ac699ab3d83c77f6/src/wallet.rs#L361-L378
    pub fn spend_spendable_outputs<C: Signing>(
        &self,
        descriptors: &[&SpendableOutputDescriptor],
        outputs: Vec<TxOut>,
        change_destination_script: Script,
        feerate_sat_per_1000_weight: u32,
        maybe_locktime: Option<PackedLockTime>,
        secp_ctx: &Secp256k1<C>,
    ) -> anyhow::Result<Option<Transaction>> {
        let num_outputs = descriptors.len();
        debug!("spend_spendable_outputs spending {num_outputs} outputs");
        let only_non_static = descriptors
            .iter()
            .filter(|d| {
                if matches!(d, SpendableOutputDescriptor::StaticOutput { .. }) {
                    debug!("Skipping StaticOutput");
                    false
                } else {
                    true
                }
            })
            .copied()
            .collect::<Vec<_>>();

        if only_non_static.is_empty() {
            debug!("spend_spendable_outputs: No non-static outputs to spend");
            return Ok(None);
        }

        self.inner
            .spend_spendable_outputs(
                &only_non_static,
                outputs,
                change_destination_script,
                feerate_sat_per_1000_weight,
                maybe_locktime,
                secp_ctx,
            )
            .map(Some)
            .map_err(|()| anyhow!("spend_spendable_outputs failed"))
    }
}

// --- LDK impls --- //

impl EntropySource for LexeKeysManager {
    fn get_secure_random_bytes(&self) -> [u8; 32] {
        self.inner.get_secure_random_bytes()
    }
}

impl NodeSigner for LexeKeysManager {
    fn get_inbound_payment_key_material(&self) -> KeyMaterial {
        self.inner.get_inbound_payment_key_material()
    }

    fn get_node_id(&self, recipient: Recipient) -> Result<PublicKey, ()> {
        self.inner.get_node_id(recipient)
    }

    fn ecdh(
        &self,
        recipient: Recipient,
        other_key: &PublicKey,
        tweak: Option<&Scalar>,
    ) -> Result<SharedSecret, ()> {
        self.inner.ecdh(recipient, other_key, tweak)
    }

    fn sign_invoice(
        &self,
        hrp_bytes: &[u8],
        invoice_data: &[u5],
        recipient: Recipient,
    ) -> Result<RecoverableSignature, ()> {
        self.inner.sign_invoice(hrp_bytes, invoice_data, recipient)
    }

    fn sign_gossip_message(
        &self,
        msg: UnsignedGossipMessage<'_>,
    ) -> Result<Signature, ()> {
        self.inner.sign_gossip_message(msg)
    }
}

impl SignerProvider for LexeKeysManager {
    type Signer = InMemorySigner;

    // Required methods
    fn generate_channel_keys_id(
        &self,
        inbound: bool,
        channel_value_satoshis: u64,
        user_channel_id: u128,
    ) -> [u8; 32] {
        self.inner.generate_channel_keys_id(
            inbound,
            channel_value_satoshis,
            user_channel_id,
        )
    }

    fn derive_channel_signer(
        &self,
        channel_value_satoshis: u64,
        channel_keys_id: [u8; 32],
    ) -> Self::Signer {
        self.inner
            .derive_channel_signer(channel_value_satoshis, channel_keys_id)
    }

    fn read_chan_signer(
        &self,
        reader: &[u8],
    ) -> Result<Self::Signer, DecodeError> {
        self.inner.read_chan_signer(reader)
    }

    fn get_destination_script(&self) -> Result<Script, ()> {
        Ok(self.destination_script.clone())
    }

    fn get_shutdown_scriptpubkey(&self) -> Result<ShutdownScript, ()> {
        Ok(self.shutdown_scriptpubkey.clone())
    }
}

#[cfg(test)]
mod test {
    use bitcoin::util::address::WitnessVersion;
    use common::rng::WeakRng;
    use proptest::{arbitrary::any, prop_assert_eq, proptest};

    use super::*;

    /// Tests that [`RootSeed::derive_node_pk`] generates the same [`NodePk`]
    /// that [`LexeKeysManager::get_node_pk`] does.
    #[test]
    fn test_rootseed_keysmanager_derivation_equivalence() {
        let any_root_seed = any::<RootSeed>();
        let any_rng = any::<WeakRng>();
        let mk_recv_address = || Address {
            // This valid payload was generated by putting this in node init:
            // println!("{:?}", wallet.get_address().await.unwrap().payload);
            payload: Payload::WitnessProgram {
                version: WitnessVersion::V0,
                program: [
                    71, 167, 97, 203, 58, 128, 110, 64, 72, 83, 112, 4, 245,
                    234, 35, 251, 92, 105, 219, 42,
                ]
                .to_vec(),
            },
            network: bitcoin::Network::Bitcoin,
        };

        proptest!(|(root_seed in any_root_seed, mut rng in any_rng)| {
            let root_seed_node_pk = root_seed.derive_node_pk(&mut rng);

            let recv_address = mk_recv_address();
            let keys_manager =
                LexeKeysManager::unchecked_init(&mut rng, &root_seed, recv_address)
                .unwrap();
            let keys_manager_node_pk = keys_manager.get_node_pk();
            prop_assert_eq!(root_seed_node_pk, keys_manager_node_pk);
        });
    }
}
